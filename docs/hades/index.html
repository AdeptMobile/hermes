<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-hades">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.3.1">
<title data-rh="true">The Hades Garbage Collector | Hermes</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://hermesengine.dev/docs/hades"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="The Hades Garbage Collector | Hermes"><meta data-rh="true" name="description" content="Hades is a garbage collector for Hermes that aims to improve pause times by an"><meta data-rh="true" property="og:description" content="Hades is a garbage collector for Hermes that aims to improve pause times by an"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://hermesengine.dev/docs/hades"><link data-rh="true" rel="alternate" href="https://hermesengine.dev/docs/hades" hreflang="en"><link data-rh="true" rel="alternate" href="https://hermesengine.dev/docs/hades" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.c0bb9412.css">
<link rel="preload" href="/assets/js/runtime~main.79f494e2.js" as="script">
<link rel="preload" href="/assets/js/main.c24be046.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Hermes Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="Hermes Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Hermes</b></a><a class="navbar__item navbar__link" href="/docs/building-and-running">Docs</a><a class="navbar__item navbar__link" href="/playground/">Playground</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebook/hermes" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/building-and-running">Documentation</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/building-and-running">Building and Running</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/emscripten">Building with Emscripten</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cross-compilation">Cross Compilation</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/language-features">Language Features</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/intl">Internationalization APIs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/memory-profilers">Memory Profilers</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design">Design Overview</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/ir">Design of the IR</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/optimizer">Design of the Optimizer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/vm">VM Overview</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/gengc">The GenGC Garbage Collector</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/hades">The Hades Garbage Collector</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/modules">Modules</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/strings">Strings</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/regexp">RegExp</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/react-native-integration">Integrations</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/coding-standards">Contributing</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Documentation</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">The Hades Garbage Collector</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>The Hades Garbage Collector</h1></header><p>Hades is a garbage collector for Hermes that aims to improve pause times by an
order of magnitude over GenGC. The main principle Hades uses to achieve those
low pause times is that most of the garbage collection work happens in a
background thread concurrently with the interpreter running JavaScript code.
This is distinct from GenGC, which only runs on a single thread which is shared
with the interpreter.</p><h1>Enabling Hades</h1><p>In local builds on the command line using CMake (which forwards to CMake), Hades
is the default GC used, and currently the only GC supported for production use.
The GC being used is controlled by the CMake variable <code>-DHERMESVM_GCKIND=value</code>.</p><p>To use a pre-built package of Hermes with Hades enabled, check the
<a href="https://github.com/facebook/hermes/releases" target="_blank" rel="noopener noreferrer">Releases page on Github</a>.
As of right now, there aren&#x27;t any available, but we&#x27;ll be making one available
with v0.8 and later.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="check-which-gc-is-used">Check Which GC is Used<a href="#check-which-gc-is-used" class="hash-link" aria-label="Direct link to Check Which GC is Used" title="Direct link to Check Which GC is Used">​</a></h2><p>If you want to know what GC is being used in your application, you can find out
with some JS:</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#FFFFFF"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#FFFFFF;background:#242526"><span class="token keyword" style="color:#c5a5c5">const</span><span class="token plain"> gcName </span><span class="token operator" style="color:#fc929e">=</span><span class="token plain"> </span><span class="token maybe-class-name">HermesInternal</span><span class="token punctuation" style="color:#657b83">.</span><span class="token method function property-access" style="color:#79b6f2">getRuntimeProperties</span><span class="token punctuation" style="color:#657b83">(</span><span class="token punctuation" style="color:#657b83">)</span><span class="token punctuation" style="color:#657b83">.</span><span class="token constant" style="color:#5a9bcf">GC</span><span class="token punctuation" style="color:#657b83">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#FFFFFF;background:#242526"><span class="token plain"></span><span class="token comment" style="color:#93a1a1">// If you&#x27;re running Hermes on the command line, use print.</span><span class="token plain"></span><br></span><span class="token-line" style="color:#FFFFFF;background:#242526"><span class="token plain"></span><span class="token function" style="color:#79b6f2">print</span><span class="token punctuation" style="color:#657b83">(</span><span class="token plain">gcName</span><span class="token punctuation" style="color:#657b83">)</span><span class="token punctuation" style="color:#657b83">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#FFFFFF;background:#242526"><span class="token plain"></span><span class="token comment" style="color:#93a1a1">// If you&#x27;re running Hermes in some kind of framework like React Native,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#FFFFFF;background:#242526"><span class="token plain"></span><span class="token comment" style="color:#93a1a1">// console.log should exist.</span><span class="token plain"></span><br></span><span class="token-line" style="color:#FFFFFF;background:#242526"><span class="token plain"></span><span class="token console class-name" style="color:#fac863">console</span><span class="token punctuation" style="color:#657b83">.</span><span class="token method function property-access" style="color:#79b6f2">log</span><span class="token punctuation" style="color:#657b83">(</span><span class="token plain">gcName</span><span class="token punctuation" style="color:#657b83">)</span><span class="token punctuation" style="color:#657b83">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This will print one of:</p><ul><li><code>&quot;hades (concurrent)&quot;</code>: You&#x27;re using Hades in concurrent mode</li><li><code>&quot;hades (incremental)&quot;</code>: You&#x27;re using Hades in <a href="#incremental-mode">incremental mode</a></li></ul><h1>Basics</h1><p>Most of the basic heap structure of Hades is similar to GenGC, so it is
recommended to read the <a href="/docs/gengc">GenGC Documentation</a> first, in particular
the following sections:</p><ul><li><a href="/docs/gengc#heap-segments">Heap Segments</a></li><li><a href="/docs/gengc#object-types">Object Types</a></li><li><a href="/docs/gengc#generations">Generations</a></li><li><a href="/docs/gengc#write-barriers">Write Barriers</a></li></ul><h1>Generations</h1><p>Similarly to GenGC, Hades also has two generations: the <strong>Young Generation</strong>
(YG) and <strong>Old Generation</strong> (OG). Allocations go initially into YG, and if they
survive the first collection they go into OG. YG works exactly the same as
GenGC, but OG has a different allocation strategy that allows for gaps.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="freelist-allocator">Freelist Allocator<a href="#freelist-allocator" class="hash-link" aria-label="Direct link to Freelist Allocator" title="Direct link to Freelist Allocator">​</a></h2><p>Hades&#x27;s OG is a list of heap segments, and each heap segment maintains a
<strong>Free List</strong> of empty space. Each <strong>Free List Cell</strong> points to the next cell,
called an explicit free list. This is opposed to an implicit free list, where
the length is used to traverse both free and used cells. A free list is used
because it allows empty space to be left where it is, without requiring
compaction. This is a requirement for concurrent allocations and sweeping.</p><p>Furthermore, the free list is <strong>size-segregated</strong>, meaning each size class gets
a separate free list. In other words, cells of size <code>N</code> only point to other
cells of size <code>N</code>. This allows an allocation of size <code>N</code> to be satisfied
instantly with the head of the free list. Each free list head is stored at an
index in a fixed-size array for small cell sizes. These are known as
<strong>buckets</strong>.</p><p>Hades does not do any rounding up of sizes beyond the required heap alignment
of 8 bytes. This means there is one bucket for each multiple of 8, up to 2048
bytes. From 2048 bytes to the maximum heap segment size (4 MiB) the buckets go
by powers of 2. For large buckets, we store cells that are greater than or equal
to the size bucket, but less than the next power of 2. Cells that need less than
the size of the free list cell <strong>carve</strong> out a small piece of the cell, and put
the remaining piece on a the free list corresponding to its new size.</p><p>Due to having these free lists be per-segment, we need a quick way to find which
segment has free space for a given size. We do this with a series of bit arrays,
where bits are flipped to 0 as a free list is exhausted in a segment, and
flipped back to 1 when sweeping frees some cells. We have per-segment free lists
so that sweeping and compaction (which also operate on a per-segment basis) can
destroy them efficiently and create a new list. It can do this to easily
coalesce adjacent free regions.</p><h1>Collection Cycles</h1><p>Hades has two different types of collections: a YG collection (YG GC) and an
OG collection (OG GC). The former is almost exactly the same as GenGC&#x27;s, so we
won&#x27;t repeat it here. The OG GC is very different though, because it runs
concurrently in a background thread.</p><p>For the purposes of distinguishing these two threads, we&#x27;ll name them as
follows:</p><ul><li><strong>Mutator Thread</strong>: The thread running the JS interpreter</li><li><strong>GC Thread</strong>: The thread running any GC operations such as marking or
sweeping</li></ul><p>Note that currently there is only ever a single GC thread at any point in time.
We also cache the thread and reuse it instead of making a new one for each
collection.</p><p>There are three different locks used throughout the GC:</p><ul><li>The <strong>GC Mutex</strong> is used to protect structures like mark bits, card tables,
and the free lists</li><li>The <strong>WeakRef Mutex</strong> is used to protect structures used during weak ref
marking</li><li>The <strong>Write Barrier Mutex</strong> is used to protect a small buffer used by write
barriers and concurrent marking</li></ul><p>The GC mutex is used to protect most things, as they tend to all be accessed at
the same time. There was no need for finer grained locks yet, with the exception
of the write barrier mutex because write barriers are executed all the time.</p><p>An OG GC is started once the OG is about 75% full. We start it a bit early so
that it can complete sweeping before reaching 100% full and avoid blocking any
allocations.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="mark-phase">Mark Phase<a href="#mark-phase" class="hash-link" aria-label="Direct link to Mark Phase" title="Direct link to Mark Phase">​</a></h2><p>The first step of an OG GC is to mark all of the roots of the object graph.
We only ever start an OG GC when YG is empty, so there&#x27;s no need to mark any of
YG.</p><p>Marking an object consists of the following steps:</p><ul><li>Using mark bits, check if an object has been visited already</li><li>If it has been visited already, there&#x27;s nothing to do</li><li>If not, push it onto a <strong>mark stack</strong> that will be drained later</li><li>Set its mark bit</li><li>If the object pointed to is a WeakMap, put it onto a separate stack
(see <a href="/docs/gengc#weak-map-resolution">Weak Map Resolution</a>)</li></ul><p>Draining the mark stack works as follows:</p><ul><li>Acquire a lock on the GC mutex</li><li>Check if the write barrier buffer has objects that need to be marked, if so,
add them to the mark stack</li><li>While we&#x27;ve marked fewer than a certain number of bytes, defaults to 8 KiB<ul><li>Pull one object off the mark stack</li><li>Get its type metadata (see <a href="/docs/gengc#object-types">Object Types</a>)</li><li>Use the metadata to find pointers to other objects</li><li>Those other objects will be pushed on the stack</li></ul></li><li>Release the lock on the GC mutex</li></ul><p>This can run almost entirely uninterrupted on the background thread since very
few things need to acquire the GC mutex. The most common way to interrupt
marking is when YG fills up, as it requires the GC mutex in order to evacuate
YG.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="write-barriers">Write Barriers<a href="#write-barriers" class="hash-link" aria-label="Direct link to Write Barriers" title="Direct link to Write Barriers">​</a></h3><p>There&#x27;s an important race condition to consider when thinking about concurrent
marking: what happens if a pointer is modified while we&#x27;re reading it?</p><p>There are two different races that are possible here:</p><ul><li>A non-atomic read of the pointer might race with a non-atomic write, and the
reads or writes might &quot;tear&quot; (meaning you see only part of the write)</li><li>You might miss marking the old value or the new value</li></ul><p>The first is handled on 64-bit platforms because all of the reads are of a 64
bit value, which can be atomically handled cheaply on a 64-bit CPU. See the
<a href="#incremental-mode">Incremental Mode</a> section for what we do on a 32-bit CPU.</p><p>The second problem is harder to solve. If we see the old value, and the new
object isn&#x27;t marked anywhere else, we would accidentally think it&#x27;s garbage and
collect it! Alternatively, if we see the new value, the old value won&#x27;t be
marked. This would be a problem if the old pointer was moved from one object to
another, but we had already marked the second object.</p><p>In order to fix this, we need to know when a pointer is modified during
concurrent marking. Hades implements this through an additional write barrier.
This write barrier is based on a principle called &quot;Snapshot at the Beginning&quot;
(SATB). The principle is that we want to collect the OG based on a snapshot
of the heap when the collection began. Which means if a pointer is changed, we
want to make sure we mark the old value instead of the new value.</p><p>This might feel counter-intuitive compared to the more common alternative
approach known as &quot;Incremental Update&quot; (IU), where the new value is marked. The
reason Hades uses SATB instead is that it has a nice guarantee: you&#x27;ll never
need to revisit any object you have already marked. This means there is a finite
upper bound on the amount of work marking has to do. IU write barrier based
systems often have a race near the end, where the GC thread needs to pause the
mutator thread to try and complete marking as fast as possible. If it exceeds
a time quota, it resumes the mutator and tries again later. We avoid this
complexity with our SATB barrier.</p><p>A second benefit of SATB is that we can treat any allocations made into OG
between the start and end of the collection as alive by default, without
needing to mark them.</p><p>And the final benefit of SATB is that there is never a need to mark the roots
again to finish a collection, as their old values were handled at the start
of the collection while the mutator was paused.</p><p>The barrier works by pushing the old value onto a small fixed size buffer, which
has space for 128 elements. Once it fills up, the Write Barrier Lock is taken to
&quot;flush&quot; the buffer into a separate mark stack used by the concurrent marker.
This means a lock is only taken every 128 write barriers. It uses a separate
mutex from the GC mutex to ensure a write barrier is not blocked for very long
if the GC thread happens to be reading from the separate mark stack.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="complete-marking">Complete Marking<a href="#complete-marking" class="hash-link" aria-label="Direct link to Complete Marking" title="Direct link to Complete Marking">​</a></h2><p>Once the mark stack is empty, there are a few details that need to be handled in
order to complete marking and move on to sweeping:</p><ul><li>Flush any remaining write barrier pointers left</li><li>Handle WeakMap resolution</li><li>Fix weak references (WeakRefs)</li></ul><p>Handling these things can be very tricky concurrently, so in order to prevent
bugs and infinite loops, we pause the mutator during this time. Even though SATB
write barriers don&#x27;t require the mutator to pause, these other operations do
require a pause, so unfortunately this is still required.</p><p>Flushing the remaining write barrier pointers just means copying the pointers
into the mark stack and draining it one more time. This could potentially take
a very long time, but in practice that is exceedingly rare.</p><p>WeakMap resolution is handled in the same way that GenGC handles it. We do this
during a mutator pause mostly because we didn&#x27;t want to rewrite the algorithm
to work in a concurrent context, as it&#x27;s already very complicated on its own.</p><p>Weak References also need to be cleared if they point to something that is
now garbage, and this is much easier to do with the mutator paused. Otherwise
the mutator would need a lock to read a weak reference value. This could be
improved to simply be an atomic operation in the future, but for now this can&#x27;t
be atomic.</p><p>Once that&#x27;s all taken care of, we can move on to sweeping.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="weakref-read-barriers">WeakRef Read Barriers<a href="#weakref-read-barriers" class="hash-link" aria-label="Direct link to WeakRef Read Barriers" title="Direct link to WeakRef Read Barriers">​</a></h3><p>There&#x27;s a caveat to mention about WeakRefs and the SATB barrier. If you read a
pointer out of a weak reference and store it in an object on the heap, SATB
won&#x27;t record the change, and the object might not be found reachable. Something
similar can happen if a weak ref is read and placed into a root.</p><p>To fix this, we have WeakRef reads perform a barrier on the pointer being read.
This conservatively assumes the pointer being read is alive. WeakRefs are not
read from that often, so this was deemed an acceptable cost.</p><p>Note that there also weak roots, such as the HiddenClass cache stored in each
CodeBlock. These do not perform a read barrier, specifically because they are
only ever used for comparisons. They never produce a pointer that was otherwise
dead. A possible simplification of this in the future could use a HiddenClass ID
instead of a pointer, as it achieves the same effect without requiring a special
case.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="sweep-phase">Sweep Phase<a href="#sweep-phase" class="hash-link" aria-label="Direct link to Sweep Phase" title="Direct link to Sweep Phase">​</a></h2><p>Once complete reachability information is known, the OG GC turns off the
SATB barriers. The sweeper iterates over one segment at a time, allowing the
mutator to interleave. This is specifically allowed because the sweeper only
ever modifies garbage objects that aren&#x27;t used, therefore there&#x27;s no races.
It holds the GC mutex to prevent YG from allocating into the OG while it&#x27;s
being swept.</p><p>The process works as follows:</p><ul><li>Acquire a lock on the GC mutex</li><li>Clear one heap segment&#x27;s free list</li><li>Iterate linearly over cells, using the embedded length to skip over live cells</li><li>Check if a cell is new garbage using its type tag</li><li>If it is not new garbage, continue to the next cell</li><li>If it is new garbage, turn it into a free list cell.</li><li>Contiguous unused regions are added as a single region onto the new free list</li><li>Once all cells in the segment have been processed, release the lock</li></ul><p>Once that process is completed for every heap segment, sweeping completes and
the OG collection is over.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="compact-phase">Compact Phase<a href="#compact-phase" class="hash-link" aria-label="Direct link to Compact Phase" title="Direct link to Compact Phase">​</a></h2><p>Compacting live memory to be closer together is still a beneficial concept in
Hades, as it allows us to return unused memory to the OS, and reduces the
fragmentation of the free lists for mostly empty heap segments. Implementing it
is more tricky than GenGC though, as we can&#x27;t modify pointers concurrently with
the mutator thread.</p><p>Due to these restrictions, we can currently only compact a single segment
(called the compactee) for each full collection. Compaction runs as part of the
collection cycle and flows as follows:</p><ol><li>At the start of an OG collection, determine whether the heap is currently
larger than its target size. If so, select and record a segment to compact.</li><li>Write barriers start dirtying cards for pointers pointing into the
compaction candidate. This will continue until the compaction is fully complete.</li><li>Marking begins. During marking, we dirty cards in the card table
corresponding to any on-heap pointers that point into the compaction candidate.
Any YG collection that occurs during marking needs special care. Promoted
objects will not be scanned by the OG since they are allocated as marked, so
they need to be scanned for compactee pointers after they have been promoted.
Furthermore, the card table cannot be cleared at the end of the YG collection,
since that would erase information from the ongoing compaction.</li><li>During the STW pause, the internal state of the GC is updated to signal that
all pointers into the compactee have been marked, and that the next YG
collection should complete the compaction.</li><li>Sweeping. The segment identified for compaction will not be swept, however
compaction may take place during sweeping if the next YG collection starts
before sweeping is complete. Note that write barriers will continue to be active
until compaction is complete, since new pointers from the OG into the compactee
may be added.</li><li>Compaction. The next young gen collection evacuates both the YG and the
compactee. It will mark long lived roots and update pointers based on the
previously dirtied cards. Combining compaction with YG collections lets us
share the overhead of updating roots, and lets us avoid tracking pointers from
the YG into the compactee.</li><li>The now empty segment is released by the GC and returned to the OS.</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="incremental-mode">Incremental Mode<a href="#incremental-mode" class="hash-link" aria-label="Direct link to Incremental Mode" title="Direct link to Incremental Mode">​</a></h2><p>Hades&#x27;s concurrent marking relies on being able to read a 64-bit value
atomically at the same time it might be modified by the mutator. If the
underlying hardware supports this natively, then we use it.
However, some hardware does not support doing those atomic reads in a lock-free
manner, primarily 32-bit ARM CPUs. Since Hermes&#x27;s main target is mobile devices,
it&#x27;s important for us to still support them, and have some of the fast pause
time guarantees that Hades gives.</p><p>In order to do this, on 32-bit platforms we don&#x27;t use any other threads, and
instead run Hades in &quot;incremental mode&quot;. This means instead of marking objects
concurrently on the GC thread, we use a portion of each YG GC to do some OG GC
work. This means the OG GC is completed incrementally on each individual YG GC.
Each YG GC takes a little bit longer while an OG GC is active, but the penalty
is small enough to still have better guarantees than running a fully blocking OG
GC.</p><p>The concurrent mode of Hades has faster pauses and is preferred to be used if
possible, but incremental mode has to be used on most 32-bit CPUs. You can also
use incremental mode if threads aren&#x27;t supported on your platform, or if you
prefer to not use threads for some other reason.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/hermes/blob/HEAD/website/../doc/Hades.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"><span class="theme-last-updated">Last updated<!-- --> on <b><time datetime="2022-04-04T22:47:29.000Z">Apr 4, 2022</time></b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/gengc"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">The GenGC Garbage Collector</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/modules"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Modules</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#check-which-gc-is-used" class="table-of-contents__link toc-highlight">Check Which GC is Used</a></li><li><a href="#freelist-allocator" class="table-of-contents__link toc-highlight">Freelist Allocator</a></li><li><a href="#mark-phase" class="table-of-contents__link toc-highlight">Mark Phase</a><ul><li><a href="#write-barriers" class="table-of-contents__link toc-highlight">Write Barriers</a></li></ul></li><li><a href="#complete-marking" class="table-of-contents__link toc-highlight">Complete Marking</a><ul><li><a href="#weakref-read-barriers" class="table-of-contents__link toc-highlight">WeakRef Read Barriers</a></li></ul></li><li><a href="#sweep-phase" class="table-of-contents__link toc-highlight">Sweep Phase</a></li><li><a href="#compact-phase" class="table-of-contents__link toc-highlight">Compact Phase</a></li><li><a href="#incremental-mode" class="table-of-contents__link toc-highlight">Incremental Mode</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/language-features">Language Features</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/building-and-running">Building and Running</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/emscripten">Building with Emscripten</a></li></ul></div><div class="col footer__col"><div class="footer__title">Integrations</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://reactnative.dev/docs/hermes" target="_blank" rel="noopener noreferrer" class="footer__link-item">Using with React Native</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/react-native-integration">Using a custom build with React Native</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://twitter.com/HermesEngine" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li><li class="footer__item"><a href="https://github.com/facebook/hermes" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div><div class="col footer__col"><div class="footer__title">Legal</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Privacy<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Terms<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://opensource.facebook.com/legal/cookie-policy/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Cookies<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><a href="https://opensource.facebook.com" rel="noopener noreferrer" class="footerLogoLink_BH7S"><img src="/img/oss_logo.png" alt="Facebook Open Source Logo" class="themedImage_ToTc themedImage--light_HNdA footer__logo"><img src="/img/oss_logo.png" alt="Facebook Open Source Logo" class="themedImage_ToTc themedImage--dark_i4oU footer__logo"></a></div><div class="footer__copyright">Copyright © 2023 Facebook, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.79f494e2.js"></script>
<script src="/assets/js/main.c24be046.js"></script>
</body>
</html>