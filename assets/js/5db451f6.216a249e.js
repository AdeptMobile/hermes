"use strict";(self.webpackChunkhermes_website=self.webpackChunkhermes_website||[]).push([[326],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return m}});var i=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=c(n),p=o,m=d["".concat(l,".").concat(p)]||d[p]||u[p]||a;return n?i.createElement(m,r(r({ref:t},h),{},{components:n})):i.createElement(m,r({ref:t},h))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,r=new Array(a);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:o,r[1]=s;for(var c=2;c<a;c++)r[c]=n[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},2278:function(e,t,n){n.r(t),n.d(t,{assets:function(){return h},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return d}});var i=n(3117),o=n(102),a=(n(7294),n(3905)),r=["components"],s={id:"design",title:"Design Overview"},l=void 0,c={unversionedId:"design",id:"design",title:"Design Overview",description:"This is the design document for the Hermes Engine.",source:"@site/../doc/Design.md",sourceDirName:".",slug:"/design",permalink:"/docs/design",draft:!1,editUrl:"https://github.com/facebook/hermes/blob/HEAD/website/../doc/Design.md",tags:[],version:"current",lastUpdatedAt:1607758573,formattedLastUpdatedAt:"Dec 12, 2020",frontMatter:{id:"design",title:"Design Overview"},sidebar:"docs",previous:{title:"Memory Profilers",permalink:"/docs/memory-profilers"},next:{title:"Design of the IR",permalink:"/docs/ir"}},h={},d=[{value:"JSON estree parser",id:"json-estree-parser",level:2},{value:"JavaScript parser",id:"javascript-parser",level:2},{value:"IRGen",id:"irgen",level:2},{value:"Hermes Bytecode Generator",id:"hermes-bytecode-generator",level:2},{value:"Hermes Bytecode Instructions",id:"hermes-bytecode-instructions",level:3},{value:"Bytecode File Format",id:"bytecode-file-format",level:3},{value:"Serialization / Deserialization",id:"serialization--deserialization",level:3},{value:"Interaction with the VM",id:"interaction-with-the-vm",level:3},{value:"Interpreter",id:"interpreter",level:2},{value:"Garbage Collector",id:"garbage-collector",level:2}],u={toc:d},p="wrapper";function m(e){var t=e.components,n=(0,o.Z)(e,r);return(0,a.kt)(p,(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This is the design document for the Hermes Engine."),(0,a.kt)("h2",{id:"json-estree-parser"},"JSON estree parser"),(0,a.kt)("h2",{id:"javascript-parser"},"JavaScript parser"),(0,a.kt)("h2",{id:"irgen"},"IRGen"),(0,a.kt)("h2",{id:"hermes-bytecode-generator"},"Hermes Bytecode Generator"),(0,a.kt)("p",null,"The Hermes bytecode generator is responsible for translating the\nHermes high-level IR into Hermes bytecode. This section only describes the\ngeneration of the opcode stream, not the whole bundle file format that is\ndescribed in a separate document."),(0,a.kt)("p",null,"The bytecode is a register-based bytecode. The number of registers is\ninfinite, but there are some restrictions on the registers. For example,\nregisters that are allocated to call instructions must be consecutive, and most\ninstructions only accept an 8-bit register index."),(0,a.kt)("p",null,"The first phase of bytecode generation is lowering of some instructions to\ntarget-specific instructions. Next, the register allocator allocates\nregisters for each instruction in the lowered IR. Notice that the Hermes IR\nhas a single return value per instruction. We model multiple return values or\nin-out variables using alloc-stack instructions."),(0,a.kt)("p",null,"One interesting design decision here is that register allocation happens on the\nIR prior to instruction selection. Performing register allocation prior to\nlowering is often done in JIT compilers where the lowering phase is trivial and\nclose to a 1:1 translation between high-level IR and the low-level target IR.\nThe lowered Hermes IR is very close to the bytecode format with a few\nexceptions: the handling of variables, the representation of constants and the\nrepresentation of stack-allocated variables. Stack allocated registers are\nimplemented as values that are pinned into a specific registers (at least during\nthe lifetime of the stack allocation). Load/Store instructions from the stack\nallocation values are lowered into MOV instructions."),(0,a.kt)("p",null,"The current register allocation implementation is a very simple linear scan. The\nallocation has four main steps. First, we number the instructions in the\nfunctions, and traverse the basic blocks in the function in reverse-post-order\nscan.  Second, we calculate the liveness graph of the result of each\ninstruction in the function. We propagate this information across the function\nwith a simple data-flow scan.  Third, we calculate the liveness interval of each\ninstruction. Finally, we scan the instructions in the function one by one and\nassign registers. We maintain a list of currently live intervals that correspond\nto the register file. We represent the register file with a simple bit vector\nand prefer to allocate registers from the beginning of the file.  When we run out\nof registers we simply allocate new registers. When we reach instructions that\nrequire target-specific handling we call the backend to fill in the details. For\nexample, the Hermes backend handles call instructions in a special way.  At the\nmoment we do not coalesce values and our PHI nodes generate two MOVs."),(0,a.kt)("p",null,"After register allocation we lower the Hermes IR into pseudo opcodes using a\none-to-one or one-to-many translation. There are a few interesting optimizations\nduring this translation.  The first interesting optimization is the optimization\nthat eliminates redundant constant jumps. It is possible to eliminate many\nbranches by scheduling basic blocks in a way that maximizes the number of\nfall-through opportunities. The current algorithm uses a greedy approach where\nwe emit basic blocks in some order (that starts with the entry block), and\nattempt to place the fall-through destination right after terminators that\nbranch (conditional and unconditional branches) if the block has not been\ngenerated already. In the future we may need to investigate if this greedy\nalgorithm is optimal."),(0,a.kt)("p",null,"When we generate the opcode stream we need to encode jump targets. However, when\nwe emit opcodes that refer to jump destinations that we have not yet emitted\nthen we do not know the address of the destination. We solve this problem by\nemitting a dummy value and keeping a side-table that saves the location that we\nneed to patch. When we finish emitting all of the opcodes we scan the side table\nand patch all of the locations that refer to previously unresolved addresses."),(0,a.kt)("h3",{id:"hermes-bytecode-instructions"},"Hermes Bytecode Instructions"),(0,a.kt)("p",null,"Hermes bytecode adopts variable-length instructions. Each operand to a bytecode\ninstruction has a fixed-type and width, defined by the opcode. For instance,\nJmp takes a 1-byte offset as the jump target, while JmpLong takes a 4-byte\noffset as the jump target.  Fixed-type/width instructions allow us to decode\nthem efficiently in the interpreter.\nHowever we are trading off with an increasing number of\nopcodes to handle different operand widths (e.g. two Jmp opcodes instead of\none). We believe that we are able to avoid opcode explosion by generating the\ncode smartly. A full list of Hermes bytecode opcodes can be found in\nBytecodeList.def. There are a few interesting design decisions worth mentioning\nhere:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Registers: We discovered that in all of the Facebook mobile JS code as well as\nmajority of external benchmarks, no function ever uses more than 256 registers.\nHence we always use 1-byte to represent register index, which will be most\nefficient for the normal cases. Spilling is implemented via MovLong which\nsupports 32 bit register indices."),(0,a.kt)("li",{parentName:"ul"},"Constants: we achieve constant loading fully through instructions.\nFor fixed-value constants such as undefined, null, true and false, we introduce\na corresponding load opcode for each of them into a register (e.g.\nLoadConstUndefined ",(0,a.kt)("inlineCode",{parentName:"li"},"dstReg"),"); For 32-bit integers, we introduce LoadConstInt\nopcode, which takes a 4-bytes immediate value and load it into a register; for\ndoubles, we introduce LoadConstDouble, which takes a 8-bytes immediate value\nand load it into a register; finally for strings, we introduce LoadConstString,\nwhich takes an index to the string table from which to load into a register.\nDoing so can significantly reduce the size of the bytecode, however it does\nintroduce a few more opcodes which could slow down the interpreter."),(0,a.kt)("li",{parentName:"ul"},"Non-local Variable Access: Local variables are translated to registers.\nNon-local variables are variables from different scopes/environments. Without a\ncompiler, accessing non-local variables in JavaScript usually means a scope\nlookup (i.e. locating the closest scope in the scope chain that defines the\nvariable), followed by a symbol lookup in that scope.\nHowever with a compiler, it is possible to statically determine the scope of\nevery variable, and hence there is no need for a real scope lookup. In Hermes\nbackend, for each non-local variable access, we simply calculate the delta\nbetween the defining scope and the current scope, and locate such scope using\nthe delta (i.e. number of times the VM needs to follow the scope chain)\ndirectly. Furthermore, since we know exactly what and how many variables are\ndefined in each scope (except the global scope), we skip the symbol lookup in\nthe scope but instead using a direct index access to retrieve such variable in\nthe located scope. We believe that skipping both scope lookups and symbol\nlookups can significantly improve the runtime performance.")),(0,a.kt)("h3",{id:"bytecode-file-format"},"Bytecode File Format"),(0,a.kt)("p",null,"The bytecode file contains the bytecode as well as necessary metadata and\nauxiliary data sections for the VM to execute properly. The file format is\ndefined in BytecodeFileFormat.h, and structures as following:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"FILE HEADER: The file header contains the MAGIC, the current format version,\nand a list of global metadata, including the file size, offset of the function\nheader table, offset of the string table, index of the global code and number\nof functions."),(0,a.kt)("li",{parentName:"ul"},"FUNCTION HEADER TABLE: This is a list of function headers. Each function header\ncontains metadata of a function, such as the offset of the function bytecode in\nthe file, number of parameters, size of the frame/environment, size of the\nbytecode and etc. This list also naturally assigns an index to each function in\nthe file, which makes access to each function convenient in the VM."),(0,a.kt)("li",{parentName:"ul"},"STRING TABLE&STORAGE: All the strings used in all functions are uniqued and\nstored in the section to avoid redundant string storage. This section contains\ntwo parts: The string storage, which is a long sequence of raw characters; the\nstring table, which is a list of pairs, each pair represents a string through\nthe offset to the string storage and the length of the string. The string table\nalso naturally assigns an index to each unique string, which makes it\nconvenient to refer to the strings in the bytecode."),(0,a.kt)("li",{parentName:"ul"},"FUNCTION BYTECODES: This section is the core section of the bytecode file,\ncontaining a list of compiled function body. The function body contains its\nexecutable bytecode, along with a few tables that are used by the bytecode,\nincluding the exception handler table (tells where to jump to when exception\nhappens), the array buffer (used to initialize constant arrays). Likely there\nwill be a few more tables coming to support RegExp and debug information.")),(0,a.kt)("h3",{id:"serialization--deserialization"},"Serialization / Deserialization"),(0,a.kt)("p",null,"Because the Hermes backend is in the same codebase as the VM, there are\nopportunities for us to share code between them. In particular, we want the\nserialization in the backend to be able to share the same target data structure\nas the deserialization in the VM. This introduces some interesting questions:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"How can we share data/code without having to link too much code on each side?"),(0,a.kt)("li",{parentName:"ul"},"How to avoid data copies during both serialization and deserialization?")),(0,a.kt)("p",null,"We introduce two design pieces to achieve code sharing efficiently:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Generator: During serialization, we often need many auxiliary data and\nfunctionality to aid the process, though many of that will not be needed in the\nend. To ensure the separation of the complexity and allow the deserialization\nto share data/code most efficiently, we use a BytecodeModuleGenerator and a\nlist of BytecodeFunctionGenerator for the purpose of generating bytecode and\nserialization. After all the processing, they will eventually generate a\nBytecodeModule and a list of BytecodeFunction that contains minimum amount of\ndata/functionality required to generate the bytecode file. Hence we can share\nthis minimum data structure between the backend and the VM."),(0,a.kt)("li",{parentName:"ul"},"StreamVector: During serialization, we need to move/copy the part of the\nauxiliary data  from the generator to the shared minimum data structure; during\ndeserialization, we need to move/copy the content of the file into the shared\nminimum data structure. Both can be expensive if not managed properly. To\nminimize the copying overhead, we abstracted the complexity using a class named\nStreamVector. During serialization, StreamVector allows us to move the data out\nof the generator without copying (through std::vector::swap); during\ndeserialization, StreamVector allows us to take in a raw data pointer to the\nmemory buffer from the file directly, without having to copy them too.")),(0,a.kt)("h3",{id:"interaction-with-the-vm"},"Interaction with the VM"),(0,a.kt)("p",null,"At runtime, the VM will deserialize the bytecode from the file and interpret\nit. A few components are involved:\nBytecodeModule: This is the in-memory representation of the whole bytecode\nfile, containing all the bytecode functions. During both serialization and\ndeserialization, this data structure is generated, as a static representation\nof the whole file."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"BytecodeFunction: This is the in-memory representation of a function\u2019s\nbytecode."),(0,a.kt)("li",{parentName:"ul"},"RuntimeModule: This is the dynamic version of the bytecode module, containing\nnecessary runtime information for interpretation."),(0,a.kt)("li",{parentName:"ul"},"CodeBlock: This is the dynamic version of the bytecode function, containing\nnecessary runtime information to execute a function."),(0,a.kt)("li",{parentName:"ul"},"Domain: A GC-managed proxy which references a set of RuntimeModules, acting as\na bridge between the GC heap and the C++ heap."),(0,a.kt)("li",{parentName:"ul"},"JSFunction: This is the Function object in JavaScript.")),(0,a.kt)("p",null,"It is important (and tricky) to efficiently manage the memory and ownership of\nthese objects properly at runtime. The following figure demonstrates it. Own\nmeans one manages the memory of the other through unique_ptr; Pointer means one\nhas a raw pointer to the other, without any ownership. Indirectly Own is a\nspecial kind of ownership, which will be explained below. To summarize the\nownership:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"JSFunction is a JavaScript object, and hence managed by the heap/garbage\ncollector directly."),(0,a.kt)("li",{parentName:"ul"},"JSFunction owns a GC-visible reference to a Domain, and a pointer to the\ncorresponding CodeBlock to execute."),(0,a.kt)("li",{parentName:"ul"},"CodeBlock contains a pointer to both the RuntimeModule to access runtime\ninformation, as well as a pointer to the corresponding BytecodeFunction which\ncontains the static function bytecode to execute."),(0,a.kt)("li",{parentName:"ul"},"BytecodeModule owns a list of BytecodeFunction."),(0,a.kt)("li",{parentName:"ul"},"RuntimeModule owns a list of CodeBlock, as well as the corresponding\nBytecodeModule."),(0,a.kt)("li",{parentName:"ul"},"Domain owns one or more RuntimeModule. This is the mechanism by which an extant\nJSFunction keeps the backing bytecode alive.")),(0,a.kt)("h2",{id:"interpreter"},"Interpreter"),(0,a.kt)("h2",{id:"garbage-collector"},"Garbage Collector"))}m.isMDXComponent=!0}}]);