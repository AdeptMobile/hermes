(self.webpackChunkhermes_website=self.webpackChunkhermes_website||[]).push([[264],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),h=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=h(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=h(n),m=o,u=p["".concat(l,".").concat(m)]||p[m]||d[m]||r;return n?a.createElement(u,i(i({ref:t},c),{},{components:n})):a.createElement(u,i({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var h=2;h<r;h++)i[h]=n[h];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},6694:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},metadata:function(){return s},toc:function(){return l},default:function(){return c}});var a=n(4034),o=n(9973),r=(n(7294),n(3905)),i={id:"gengc",title:"The GenGC Garbage Collector"},s={unversionedId:"gengc",id:"gengc",isDocsHomePage:!1,title:"The GenGC Garbage Collector",description:"GenGC used to be the default garbage collector for Hermes, and aims to provide a",source:"@site/../doc/GenGC.md",sourceDirName:".",slug:"/gengc",permalink:"/docs/gengc",editUrl:"https://github.com/facebook/hermes/blob/HEAD/website/../doc/GenGC.md",version:"current",lastUpdatedAt:1617994801,formattedLastUpdatedAt:"4/9/2021",frontMatter:{id:"gengc",title:"The GenGC Garbage Collector"},sidebar:"docs",previous:{title:"VM Overview",permalink:"/docs/vm"},next:{title:"The Hades Garbage Collector",permalink:"/docs/hades"}},l=[{value:"Allocate directly into the Old Geneneration (Pre-Tenuring)",id:"allocate-directly-into-the-old-geneneration-pre-tenuring",children:[]},{value:"Young Generation Collection",id:"young-generation-collection",children:[{value:"Write Barriers",id:"write-barriers",children:[]}]},{value:"Full Collection",id:"full-collection",children:[{value:"Mark Phase",id:"mark-phase",children:[]},{value:"Weak Map resolution",id:"weak-map-resolution",children:[]},{value:"Sweep &amp; Compact Phases",id:"sweep--compact-phases",children:[]}]}],h={toc:l};function c(e){var t=e.components,i=(0,o.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,a.Z)({},h,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"GenGC used to be the default garbage collector for Hermes, and aims to provide a\ngenerational garbage collector that returns memory to the OS aggressively and\nfrequently. The newer GC is called ",(0,r.kt)("a",{parentName:"p",href:"/docs/hades"},"Hades"),", and it has much lower\npause times than GenGC. We recommend most users use Hades instead."),(0,r.kt)("p",null,"Throughout this document, we will refer to the ",(0,r.kt)("strong",{parentName:"p"},"heap"),", which in this context\nmeans the memory space where JS objects reside. This is separate from the C and\nC++ ",(0,r.kt)("inlineCode",{parentName:"p"},"malloc"),' heap, and in general if this document says "heap" it means the\nspace for JS objects.'),(0,r.kt)("h1",{id:"heap-segments"},"Heap Segments"),(0,r.kt)("p",null,"The heap is made out of many fixed-size regions of memory known as\n",(0,r.kt)("strong",{parentName:"p"},"heap segments")," (or more briefly as ",(0,r.kt)("strong",{parentName:"p"},"segments"),"). Currently these segments\nare 4 MiB, but this can be changed with the CMake build configuration variable\n",(0,r.kt)("inlineCode",{parentName:"p"},"-DHERMESVM_HEAP_SEGMENT_SIZE_KB=number"),". Memory is acquired and released on a\nper-segment basis. Segments are allocated using ",(0,r.kt)("inlineCode",{parentName:"p"},"mmap")," on POSIX systems and\n",(0,r.kt)("inlineCode",{parentName:"p"},"VirtualAlloc")," on Windows systems. These functions allow virtual memory to be\nrequested for some space, and allows us to unmap subregions so that alignment\ncan be guaranteed. This is done in separate regions because we found that a lot\nof devices have trouble allocating enough virtual memory upfront to have the\nentire heap be contiguous. By allowing it to grow virtual address space usage\nwith the size of the heap (and shrink as well), it works on a broader set of\ndevices. We chose 4 MiB as the size of segments because it was small enough to\nnot exhaust virtual address space, while also being large enough to not have a\nlot of overhead in managing the segments."),(0,r.kt)("p",null,"Each heap segment is aligned to begin on a pointer address that is a multiple\nof its size. For example, if segments are 4 MiB wide, then their start\naddresses are aligned on a 4 MiB boundary (the low 22 bits are all 0). This\nmeans for any pointer into the JS heap, you can get the segment start address\nwith a simple bitwise-and operation. All metadata for the segment is stored at\nthe front of the segment."),(0,r.kt)("p",null,"At the beginning of a segment, there is a small amount of memory reserved for\nsome metadata about the heap. Specifically, the following things are kept there:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Segment ID: explained in ",(0,r.kt)("a",{parentName:"li",href:"#compressed-pointers"},"Compressed Pointers")),(0,r.kt)("li",{parentName:"ul"},"CardTable: explained in ",(0,r.kt)("a",{parentName:"li",href:"#generations"},"Generations")),(0,r.kt)("li",{parentName:"ul"},"MarkBitArray: explained in ",(0,r.kt)("a",{parentName:"li",href:"#mark-phase"},"Mark Phase")),(0,r.kt)("li",{parentName:"ul"},"Guard page: a page of memory that is protected from reads and writes to ensure\nbugs in the VM or GC don't accidentally overwrite metadata.")),(0,r.kt)("p",null,"The rest of the segment is free space available for JS values to be allocated\ninto. See\n",(0,r.kt)("a",{target:"_blank",href:n(6775).Z},(0,r.kt)("code",null,"AlignedHeapSegment::Contents")),"\nfor details about the layout of a heap segment."),(0,r.kt)("h1",{id:"object-types"},"Object Types"),(0,r.kt)("p",null,"In order to determine reachability, we need to be able to discover\nwhat objects point to. To do this for the variety of types in Hermes, we\ndefine a system of metadata for each object, associated to its type which is\nencoded as a ",(0,r.kt)("inlineCode",{parentName:"p"},"VTable"),". Metadata is built once for the first Runtime created, and\nis then re-used for every subsequent runtime. The metadata describes at what\noffsets from the head of an object there are pointers. It also describes for\nany array type where the length of the array can be found, so a dynamic number\nof pointers can be found. This design allows pointers to be marked without\nperforming any type checks, branches, or virtual dispatch."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"VTable *")," is embedded in the header of everything allocated on the heap.\nThis is represented by the C++ superclass of all heap objects, called ",(0,r.kt)("inlineCode",{parentName:"p"},"GCCell"),".\nThis way, given a pointer to something in the heap, its type (and pointer\nmetadata) can be found. The type is stored as a ",(0,r.kt)("inlineCode",{parentName:"p"},"CellKind")," enum. The ",(0,r.kt)("inlineCode",{parentName:"p"},"VTable"),"\nalso includes function pointers for dynamic dispatch. This is used to implement\ntype-based dispatch for things like property accesses and function calls."),(0,r.kt)("h1",{id:"generations"},"Generations"),(0,r.kt)("p",null,"GenGC is so named because it is ",(0,r.kt)("strong",{parentName:"p"},"generational"),", meaning it manages groups of\nallocated objects based on their age. Age is determined by how many collections\nan object has survived. GenGC has two generations: the ",(0,r.kt)("strong",{parentName:"p"},"Young Generation")," (YG)\nand ",(0,r.kt)("strong",{parentName:"p"},"Old Generation")," (OG).\nAllocations go initially into YG, and if they survive the first YG collection\ncycle, they are promoted to OG. The OG is collected less frequently and over a\nlarger number of objects. YG is collected frequently because it is assumed that\nthere are a lot of objects that were allocated but became garbage quickly. This\nis known as the\n",(0,r.kt)("a",{parentName:"p",href:"https://www.memorymanagement.org/glossary/g.html#generational.hypothesis"},"Generational Hypothesis"),":\nyoung objects are more likely to die than old objects."),(0,r.kt)("p",null,"The young generation of GenGC is a single segment, regardless of the size\nof the heap as a whole. Since YG is much smaller than OG, this is also a much\nshorter pause to collect YG. Since the YG is also a single segment, it's very\nfast to check if a pointer is a YG pointer: get the segment start address and\ncompare to the YG start address. The allocation algorithm is as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'Attempt to allocate into the YG segment by bumping a pointer called the\n"level" of the segment up. If the level would go past the end of the segment, it\nfails'),(0,r.kt)("li",{parentName:"ul"},"If the bump allocation succeeds, the allocation is complete and control\nreturns to the VM"),(0,r.kt)("li",{parentName:"ul"},"If the bump allocation fails, start a YG collection cycle. This will evacuate\nthe YG into the OG, and leave some empty space."),(0,r.kt)("li",{parentName:"ul"},"Try bump allocation again after the YG collection cycle completes. If it\nsucceeds, return."),(0,r.kt)("li",{parentName:"ul"},"Else, try to allocate directly into the OG."),(0,r.kt)("li",{parentName:"ul"},"If the OG is full, start a full collection cycle (collect garbage in both the\nYG and OG). Once that completes, try allocating directly into OG again."),(0,r.kt)("li",{parentName:"ul"},"If all that fails, that means there's not enough space for the allocation,\nraise an Out of Memory (OOM) error")),(0,r.kt)("p",null,"The old generation of GenGC is a list of segments, each of which is created\nafter an allocation failed in the previous segment. The OG maintains an\nallocation context which remembers the most recent active segment, and this is\nwhere promoted YG objects are allocated into. Once the OG has reached its\nconfigured size limit, it will do a full collection, trying to free garbage\ninside the OG."),(0,r.kt)("p",null,"There are more details on collection cycles in the\n",(0,r.kt)("a",{parentName:"p",href:"#collection-cycles"},"Collection Cycles")," section."),(0,r.kt)("h2",{id:"allocate-directly-into-the-old-geneneration-pre-tenuring"},"Allocate directly into the Old Geneneration (Pre-Tenuring)"),(0,r.kt)("p",null,"Sometimes there are applications where the generational hypothesis doesn't hold\ntrue, or in other words they allocate more objects that are long-lived than\nshort-lived. This typically occurs during the initialization period of an\napplication. If this rule applies to your application, you can request this\nbehavior from Hermes by changing the ",(0,r.kt)("inlineCode",{parentName:"p"},"GCConfig")," that's used at Runtime\nconstruction time:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"hermes::vm::GCConfig::Builder gcConfigBuilder{};\ngcConfigBuilder\n    .withAllocInYoung(false)\n    .withRevertToYGAtTTI(true);\nstd::unique_ptr<jsi::Runtime> runtime = makeHermesRuntime(\n    hermes::vm::RuntimeConfig::Builder()\n        .withGCConfig(gcConfigBuilder.build())\n);\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"AllocInYoung")," parameter defaults to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", and controls whether\nallocations go into YG by default or OG.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"RevertToYGAtTTI")," parameter defaults to ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),", and is unused unless\n",(0,r.kt)("inlineCode",{parentName:"p"},"AllocInYoung")," is true."),(0,r.kt)("p",null,"See the full documentation of ",(0,r.kt)("a",{target:"_blank",href:n(7530).Z},"GCConfig")," for\nmore details and other configuration options."),(0,r.kt)("h1",{id:"collection-cycles"},"Collection Cycles"),(0,r.kt)("p",null,"GenGC determines garbage that can be collected in a program based on what is\nreachable in the graph of objects. The graph has ",(0,r.kt)("strong",{parentName:"p"},"roots")," that define the\nentrypoint to the graph. These are typically things like variables on the\nJS call stack. From the roots, the entire graph of objects is traversed by\nfollowing each property to another object. Think of it as similar to a\ntraditional graph search algorithm, although we make many optimizations specific\nto the heap structure."),(0,r.kt)("p",null,'GenGC has two different types of garbage collection cycles\n(abbreviated as "GC"). There is a Young Generation Collection or YG GC, and a\nFull Collection or full GC.\nA YG GC collects only objects present in the YG, and promotes objects that are\nreachable to the OG so they are collected less frequently.\nA full GC collects both the OG and YG simultaneously, and determines the\nreachability of every object in the heap.'),(0,r.kt)("p",null,"There are two common concepts across both types of collections:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'Mark: Marking means setting some state related to an object to say that it was\nfound to be reachable during the traversal of the heap. In GenGC\'s case, this\nis often referred to as a "mark bit"'),(0,r.kt)("li",{parentName:"ul"},"Sweep: Sweeping means reclaiming unused space so that it can be re-used by the\nallocator. This can look very different depending on the generation")),(0,r.kt)("h2",{id:"young-generation-collection"},"Young Generation Collection"),(0,r.kt)("p",null,"When a YG collection is triggered, it first needs to mark the roots of the\nobject graph. Because YG collections occur very frequently, we want the set of\nroots to be small. To achieve this we ignore any roots that are known to be\nonly in the OG. When each pointer is discovered for the first time, an\nallocation is made in the OG for the same size, the YG object's contents are\ncopied, and a forwarding pointer is left in the header of the YG object pointing\nto the new OG object. After that, if we see the same pointer again, we replace\nit with the value of the forwarding pointer."),(0,r.kt)("p",null,"We also need to consider any OG objects that point into YG as part of the root\nset. That is handled by a separate mechanism during JS execution, detailed below\nin the section on ",(0,r.kt)("a",{parentName:"p",href:"#write-barriers"},"Write Barriers"),"."),(0,r.kt)("p",null,"To find all the reachable objects, we take advantage of the linear nature of\nOG, and scan linearly from the original end of the allocated region, until\nthere aren't any more promoted objects. Each promoted object is scanned for its\nown pointers. This is how all YG objects are discovered. It's similar to a\nsemi-space algorithm where the second space is the OG."),(0,r.kt)("p",null,"Once the objects are all moved, any weak references pointing to YG objects are\nupdated if the object is still alive, and then any finalizers are run by\niterating over a list of finalizers."),(0,r.kt)("h3",{id:"write-barriers"},"Write Barriers"),(0,r.kt)("p",null,"As part of the root set, we also consider any OG objects that point into YG.\nTo determine where these exist without iterating over the whole OG, we use a\n",(0,r.kt)("strong",{parentName:"p"},"write barrier")," whenever a pointer value is written to during JS execution.\nIf it would create an old -> young pointer, we want to mark the source object\nas part of the root set of YG."),(0,r.kt)("p",null,"The way we do this is by classifying a small region of memory in the OG as a\n",(0,r.kt)("strong",{parentName:"p"},"card"),", currently 512 bytes. We determine the card for a pointer using the\nsame alignment trick to get the base address of the segment, then use division\nto figure out the card index. The ",(0,r.kt)("strong",{parentName:"p"},"card table")," is a list of bytes stored in\nthe header of the segment, and when we find an object pointing into the YG, we\n\"dirty\" its card by setting the byte value to 1. We don't use a bitmap because\nthe card table is only 8 KiB, and shrinking it further isn't worth it."),(0,r.kt)("p",null,"During YG collection time, we can quickly scan each card table for the set of\ndirtied cards, then we mark all of the objects on that card. We use a separate\n",(0,r.kt)("strong",{parentName:"p"},"card object table"),' to find the first object for a card. That table contains\nanother byte per card, except it is signed. If the sign is positive, it means\n"go back that many bytes to find the first object on this card". If the sign\nis negative, it means "go back that many cards and check the table at that\nindex". This encoding scheme allows a low memory cost way to jump across very\nlarge objects.'),(0,r.kt)("p",null,"Note that the way cards are dirtied means there's a chance of promoting some\nYG objects that aren't actually live. This tradeoff is chosen so the cards take\nup less memory and can be scanned quickly. Smaller cards are more precise, but\ntake up more memory and require more scanning."),(0,r.kt)("h2",{id:"full-collection"},"Full Collection"),(0,r.kt)("p",null,"A full collection is much larger than a YG collection, so it happens less\nfrequently. It needs to determine the reachability of every object in the heap.\nA full collection is triggered when the OG doesn't have enough space to satisfy\nan allocation from a YG promotion or a direct-to-OG allocation."),(0,r.kt)("h3",{id:"mark-phase"},"Mark Phase"),(0,r.kt)("p",null,"The collection begins with a call to ",(0,r.kt)("inlineCode",{parentName:"p"},"markRoots"),", although this time\nadditionally marking roots known to only point into the OG, such as the\n",(0,r.kt)("inlineCode",{parentName:"p"},"IdentifierTable"),". The first time an object is encountered, it sets a bit in the\nmark bit array, so future accesses know that it has already been found. Then we\npush the newly discovered object on top of a ",(0,r.kt)("strong",{parentName:"p"},"mark stack"),"."),(0,r.kt)("p",null,"The mark stack is drained by popping off the top object, scanning all of its\npointers, and pushing objects it discovers onto the mark stack."),(0,r.kt)("p",null,"There are two changes implemented to prevent the mark stack from growing without\nbound:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If a pointer to an object is discovered that is after the current address, it\nisn't pushed on the mark stack. Instead, we jump to the next marked bit when\nthe mark stack is empty. If the pointer is before the current address, it has to\nbe pushed on the stack because we won't go backwards in the heap normally"),(0,r.kt)("li",{parentName:"ul"},"If the mark stack overflows a limit, we drop the whole stack and re-scan from\nthe beginning of the heap. Since many objects have already been marked, this\nwill go much faster than previous times. It's guaranteed to terminate because\nin the worst case eventually every object will be marked and there's nothing\nto collect.")),(0,r.kt)("p",null,"Once the marking is complete this way, full reachability is known, and sweeping\ncan begin."),(0,r.kt)("h3",{id:"weak-map-resolution"},"Weak Map resolution"),(0,r.kt)("p",null,"However, one problem to be handled are ",(0,r.kt)("strong",{parentName:"p"},"weak references"),", which are pointers\nthat do not keep what they point to alive. Now that we know reachability, we\nknow which weak pointers to make null."),(0,r.kt)("p",null,"But there's a special case of the JS type ",(0,r.kt)("inlineCode",{parentName:"p"},"WeakMap")," that has to be handled:\nthe keys are weak, and the values are strong, unless they keep the key itself\nalive. This means the values can't be marked until the key is determined\nreachable through some other means."),(0,r.kt)("p",null,"We delay marking any WeakMap key/value pairs until the end of marking. Then for\neach WeakMap, and for each key that is reachable in the weak map, we then mark\nthe value. If marking the value ends up making another WeakMap key reachable,\nwe then need to mark that. We repeat this for every key that becomes reachable\nuntil there's nothing more to mark. At that point we can finally null out keys\nthat were never found to be reachable."),(0,r.kt)("h3",{id:"sweep--compact-phases"},"Sweep & Compact Phases"),(0,r.kt)("p",null,"Now that full reachability has been computed, we know which objects are garbage.\nWe want to reclaim that memory so that it can be allocated again. To do so, we\nwill ",(0,r.kt)("strong",{parentName:"p"},"compact")," all live memory down so that there's no space between them,\noverwriting the space that was used by dead objects."),(0,r.kt)("p",null,"To do this, we iterate through every live object in the heap using the mark\nbits, and for each one we compute its new address. We place that new address\nas a forwarding pointer in the header of the object (displacing the ",(0,r.kt)("inlineCode",{parentName:"p"},"VTable *"),"\nto a temporary vector to avoid losing the type information). Once a forwarding\npointer has been determined for everything in the heap, we do a second pass to\nfixup pointers within objects to use the forwarded value. Finally, we copy the\nmemory from the previous location to the new location, overwriting whatever used\nto be there."),(0,r.kt)("p",null,"The end result of this is that all live memory sits right next to each other in\nthe heap segments, and all dead memory has now been reclaimed for the allocator.\nWe use ",(0,r.kt)("inlineCode",{parentName:"p"},"madvise")," on POSIX systems to tell the operating system that the leftover\nmemory is now not needed by the program, and it's free to be paged out and zero\nfilled if the OS needs to."),(0,r.kt)("p",null,"At this point control returns to the JS engine, typically to finish the\nallocation that started the collection."))}c.isMDXComponent=!0},6775:function(e,t,n){"use strict";t.Z=n.p+"assets/files/AlignedHeapSegment-1f8beb091b98feb2622d53d1f4c90501.h"},7530:function(e,t,n){"use strict";t.Z=n.p+"assets/files/GCConfig-3f5cf5901e83f78936d2922aa5bcb9c8.h"}}]);