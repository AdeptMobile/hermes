"use strict";(self.webpackChunkhermes_website=self.webpackChunkhermes_website||[]).push([[20],{3905:function(t,e,a){a.d(e,{Zo:function(){return p},kt:function(){return c}});var n=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function o(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var s=n.createContext({}),m=function(t){var e=n.useContext(s),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},p=function(t){var e=m(t.components);return n.createElement(s.Provider,{value:e},t.children)},d="mdxType",u={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},k=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,l=t.originalType,s=t.parentName,p=o(t,["components","mdxType","originalType","parentName"]),d=m(a),k=r,c=d["".concat(s,".").concat(k)]||d[k]||u[k]||l;return a?n.createElement(c,i(i({ref:e},p),{},{components:a})):n.createElement(c,i({ref:e},p))}));function c(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=a.length,i=new Array(l);i[0]=k;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=t,o[d]="string"==typeof t?t:r,i[1]=o;for(var m=2;m<l;m++)i[m]=a[m];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},4719:function(t,e,a){a.r(e),a.d(e,{assets:function(){return p},contentTitle:function(){return s},default:function(){return c},frontMatter:function(){return o},metadata:function(){return m},toc:function(){return d}});var n=a(3117),r=a(102),l=(a(7294),a(3905)),i=["components"],o={id:"ir",title:"Design of the IR"},s=void 0,m={unversionedId:"ir",id:"ir",title:"Design of the IR",description:"Introduction",source:"@site/../doc/IR.md",sourceDirName:".",slug:"/ir",permalink:"/docs/ir",draft:!1,editUrl:"https://github.com/facebook/hermes/blob/HEAD/website/../doc/IR.md",tags:[],version:"current",lastUpdatedAt:1679944014,formattedLastUpdatedAt:"Mar 27, 2023",frontMatter:{id:"ir",title:"Design of the IR"},sidebar:"docs",previous:{title:"Design Overview",permalink:"/docs/design"},next:{title:"Design of the Optimizer",permalink:"/docs/optimizer"}},p={},d=[{value:"Introduction",id:"introduction",level:3},{value:"Well-Formedness",id:"well-formedness",level:3},{value:"Frames:",id:"frames",level:3},{value:"Types:",id:"types",level:3},{value:"Example:",id:"example",level:3},{value:"Side Effects:",id:"side-effects",level:3},{value:"Register allocation",id:"register-allocation",level:2},{value:"Generator Overview",id:"generator-overview",level:2},{value:"Instruction semantics",id:"instruction-semantics",level:2},{value:"BranchInst",id:"branchinst",level:3},{value:"ReturnInst",id:"returninst",level:3},{value:"AllocStackInst",id:"allocstackinst",level:3},{value:"LoadFrameInst",id:"loadframeinst",level:3},{value:"LoadStackInst",id:"loadstackinst",level:3},{value:"StoreFrameInst",id:"storeframeinst",level:3},{value:"StoreStackInst",id:"storestackinst",level:3},{value:"AsNumberInst",id:"asnumberinst",level:3},{value:"AsInt32Inst",id:"asint32inst",level:3},{value:"AddEmptyStringInst",id:"addemptystringinst",level:3},{value:"CondBranchInst",id:"condbranchinst",level:3},{value:"CompareBranchInst",id:"comparebranchinst",level:3},{value:"CreateScopeInst",id:"createscopeinst",level:3},{value:"CreateInnerScopeInst",id:"createinnerscopeinst",level:3},{value:"CreateFunction",id:"createfunction",level:3},{value:"BinaryOperatorInst",id:"binaryoperatorinst",level:3},{value:"DirectEvalInst",id:"directevalinst",level:3},{value:"CallInst",id:"callinst",level:3},{value:"ConstructInst",id:"constructinst",level:3},{value:"CallBuiltinInst",id:"callbuiltininst",level:3},{value:"CallIntrinsicInst",id:"callintrinsicinst",level:3},{value:"GetBuiltinClosureInst",id:"getbuiltinclosureinst",level:3},{value:"LoadPropertyInst",id:"loadpropertyinst",level:3},{value:"DeletePropertyInst",id:"deletepropertyinst",level:3},{value:"StorePropertyInst",id:"storepropertyinst",level:3},{value:"TryStoreGlobalPropertyInst",id:"trystoreglobalpropertyinst",level:3},{value:"StoreOwnPropertyInst",id:"storeownpropertyinst",level:3},{value:"StoreNewOwnPropertyInst",id:"storenewownpropertyinst",level:3},{value:"StoreGetterSetterInst",id:"storegettersetterinst",level:3},{value:"ThrowIfHasRestrictedGlobalPropertyInst",id:"throwifhasrestrictedglobalpropertyinst",level:3},{value:"AllocObjectInst",id:"allocobjectinst",level:3},{value:"AllocObjectLiteralInst",id:"allocobjectliteralinst",level:3},{value:"AllocArrayInst",id:"allocarrayinst",level:3},{value:"CreateArgumentsInst",id:"createargumentsinst",level:3},{value:"CreateRegExpInst",id:"createregexpinst",level:3},{value:"SwitchInst",id:"switchinst",level:3},{value:"GetPNamesInst",id:"getpnamesinst",level:3},{value:"GetNextPNameInst",id:"getnextpnameinst",level:3},{value:"CatchInst",id:"catchinst",level:3},{value:"ThrowInst",id:"throwinst",level:3},{value:"CheckHasInstanceInst",id:"checkhasinstanceinst",level:3},{value:"TryStartInst",id:"trystartinst",level:3},{value:"TryEndInst",id:"tryendinst",level:3},{value:"PhiInst",id:"phiinst",level:3},{value:"MovInst",id:"movinst",level:3},{value:"ImplicitMovInst",id:"implicitmovinst",level:3},{value:"DebuggerInst",id:"debuggerinst",level:3},{value:"GetNewTargetInst",id:"getnewtargetinst",level:3},{value:"ThrowIfEmptyInst",id:"throwifemptyinst",level:3},{value:"CoerceThisNS",id:"coercethisns",level:3},{value:"CreateGenerator",id:"creategenerator",level:3},{value:"StartGenerator",id:"startgenerator",level:3},{value:"SaveAndYield",id:"saveandyield",level:3},{value:"ResumeGenerator",id:"resumegenerator",level:3},{value:"IteratorBegin",id:"iteratorbegin",level:3},{value:"IteratorNext",id:"iteratornext",level:3},{value:"IteratorClose",id:"iteratorclose",level:3},{value:"UnreachableInst",id:"unreachableinst",level:3},{value:"Target Instructions",id:"target-instructions",level:2},{value:"HBCGetGlobalObjectInst",id:"hbcgetglobalobjectinst",level:3},{value:"HBCCreateEnvironment",id:"hbccreateenvironment",level:3},{value:"HBCCreateInnerEnvironment",id:"hbccreateinnerenvironment",level:3},{value:"HBCCreateFunction",id:"hbccreatefunction",level:3},{value:"HBCCreateGenerator",id:"hbccreategenerator",level:3},{value:"HBCAllocObjectFromBufferInst",id:"hbcallocobjectfrombufferinst",level:3},{value:"HBCCallNInst",id:"hbccallninst",level:3}],u={toc:d},k="wrapper";function c(t){var e=t.components,a=(0,r.Z)(t,i);return(0,l.kt)(k,(0,n.Z)({},u,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h3",{id:"introduction"},"Introduction"),(0,l.kt)("p",null,"This document is a reference manual for the Hermes High-level IR. The IR is a\nStatic Single Assignment (SSA) based representation that captures the JavaScript\nlanguage semantics. It features optional types (values may be annotated with\ntypes)."),(0,l.kt)("p",null,"The IR representation is designed to be used as an in-memory form. The IR can be\ndumped to human readable assembly-like format."),(0,l.kt)("h3",{id:"well-formedness"},"Well-Formedness"),(0,l.kt)("p",null,"This section describes the rules that define a valid IR."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Instructions must be dominated by their operands.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Basic block must end with a terminator, which is a branch instruction or a\nreturn instruction.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"There has to be exactly one terminator for each basic block.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"AllocStack instructions must appear at the 'entry' basic block (the first basic\nblock in the function).")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"PHI Nodes must appear at the beginning of the basic block and must contain\nan entry for each predecessor."))),(0,l.kt)("h3",{id:"frames"},"Frames:"),(0,l.kt)("p",null,"Every JavaScript function is a closure that can capture variables from its\ndeclaration scope. The declaration scope may be the global scope or another\nfunction. A closure is a pair of function code, which contains the code of the\nfunction, and a context which saves the environment that the closure may access."),(0,l.kt)("p",null,"Function variables that are captured by a closure are allocated in a scope on\nthe heap and the scope is passed as part of the context to the closure.\nClosures may access variables at all nest-levels, which means that they can\naccess multiple scopes. We implement this feature by nesting scopes and linking\nthem together. Each scope (the set of captured variables) also has a reference\nto the scope of the caller function. Closures can access variables at different\nnesting levels by loading the parent scope for each scope."),(0,l.kt)("p",null,"At the IR Level we define a few instructions that can load and store frame\nvariables.  Functions own variables, that are storage units that represent\nvariables at the source level.  These variables can be optimized away or\npromoted to the stack, etc.  We define the AllocStack instruction for allocating\nvariable storage. The only instructions that can access the storage values\n(Variable and AllocStack) are the Load and Store instructions. It is not\npossible to save the address of the allocation itself. Depending on the\nimplementation of the virtual machine, the heap allocations may be packed into a\nsingle frame."),(0,l.kt)("h3",{id:"types"},"Types:"),(0,l.kt)("p",null,"The Hermes high-level IR is optionally typed. Values may be annotated with the\nexpected type of the value. The types are optional and untyped programs are\ncorrect. The types represent primitive JavaScript types, or refinement of these\ntypes. All values can be annotated with types: Functions, Instructions and\nParameters. Annotations of functions represent the type of the returned value.\nThe type annotations are not a suggestion or a hint. They must be correct and\nconsistent or else the program may fail at run time. Programs are expected to\nrun and have the same semantics when the type annotations are stripped."),(0,l.kt)("p",null,"Some instructions in the IR expect operands of specific types, or produce\nspecific types.  For example, the CondBranch instruction expects the condition\noperand to be annotated as a boolean type. The ToBool instruction produces\nvalues that are annotated as boolean type."),(0,l.kt)("p",null,"The optimizer may optimize the IR based on type annotations. For example, if the\noperand of the instruction ToBool is annotated with the boolean type then the\noptimizer is free to remove the instruction and replace all uses with the\noperand of the conversion instruction."),(0,l.kt)("h3",{id:"example"},"Example:"),(0,l.kt)("p",null,"This is a short example of a valid program in textual IR. The function contains\nfour basic blocks with a few instructions. The code below follow the\nrequirements of a well-formed function defined in the previous section."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"  function forEach(cond : boolean, value : number)\n    %BB0:\n      %0 = BranchInst %BB1\n    %BB1:\n      %2 = CondBranchInst %cond, %BB2, %BB3\n    %BB2:\n      %3 = ReturnInst %cond\n    %BB3:\n      %4 = ReturnInst %value\n")),(0,l.kt)("h3",{id:"side-effects"},"Side Effects:"),(0,l.kt)("p",null,"The instructions in the IR are annotated with side effect labels. The\nlabels describe the kind of effect the instruction has on memory, IO\nstate (for example, hardware IO such as drawing to a screen or sending\na network packet), and whether they can throw. The two kind of memory\nside effects are 'read' and 'write'.  ('write' actually indicates\n\"read and/or write\".)  These side effect specifications indicate that\nthe instruction does not have IO effects or throw.  The 'unknown' side\neffect is maximally conservative: it indicates that the instruction\nmay read, write, have IO effects, and/or throw.  These side effect\nannotations allow the optimizer to decide which optimizations are\nlegal. For example, it is not legal to sink instructions that can\nwrite to memory past each other. It is not legal to hoist instructions\nthat read to memory outside of a loop if there is another instruction\nthat writes to memory in that loop, because the writer instruction may\nclobber memory that the reader may read."),(0,l.kt)("p",null,"Some instructions that allocate memory are marked as not having any side\neffects.  This is because the instructions only touch the newly allocated memory\nand do not influence the rest of the heap. Notice that we don't model the effect\nof instructions on the garbage collector or anything like that, just the content\nof the allocated memory."),(0,l.kt)("h2",{id:"register-allocation"},"Register allocation"),(0,l.kt)("p",null,"In Hermes, register allocation is performed on the IR. An infinite number of\nvirtual registers are allocated while preserving the constraints of the IR and\nof the low-level target. Registers are allocated in an attempt to reduce the\nnumber of registers, values across PhiNodes are coalesced, AllocStack\ninstructions are assigned with a dedicated register and arguments to call\ninstructions are placed in consecutive registers."),(0,l.kt)("p",null,"While in SSA form, the IR does not support all of the things that can be done\nwith registers. This is why the Register Allocator introduces MOV instructions\nthat represent a copy of one register to another. We lower some of the\nload/store instructions into MOVs, and spill registers with MOV instructions."),(0,l.kt)("h2",{id:"generator-overview"},"Generator Overview"),(0,l.kt)("p",null,"When generating the IR for a generator function, we make two functions:\nan outer GeneratorFunction and an inner function.\nThe outer function calls CreateGenerator on the inner function,\nand returns the resultant generator."),(0,l.kt)("p",null,"The inner function assumes that it can store and retrieve state from\nits own closure. As such, it contains instructions to start, save/yield,\nand resume generators."),(0,l.kt)("p",null,"CreateGenerator:\nAn instruction to create a generator given a ",(0,l.kt)("inlineCode",{parentName:"p"},"Function"),".\nFirst, it creates an inner GeneratorInnerFunction, then it wraps it in a Generator object.\nUsed by the GeneratorFunction to create the generator which is returned upon calling it."),(0,l.kt)("p",null,"StartGenerator:\nAlways the first instruction executed when an inner function is called.\nRestores values for all local variables in the generator,\nand jumps to the resume point of the generator if it's suspended.\nIf the generator hasn't been started yet, simply continues execution."),(0,l.kt)("p",null,"SaveAndYield:\nSaves necessary state to the closure and yields execution.\nIn practice, this will save state and use the return opcode to\nallow the caller to get the yield result.\nEmitting a SaveAndYield also emits its corresponding ResumeGenerator."),(0,l.kt)("p",null,"ResumeGenerator:\nPlaced at the start of the block following the SaveAndYield to which it\ncorresponds. Resumes execution by loading context from the closure,\nand then using state stored in the closure, does one of 3 things:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Continues execution with the result of the instruction being the\nargument to ",(0,l.kt)("inlineCode",{parentName:"li"},".next()"),"."),(0,l.kt)("li",{parentName:"ul"},"Throws a value immediately"),(0,l.kt)("li",{parentName:"ul"},"Sets an ",(0,l.kt)("inlineCode",{parentName:"li"},"%isReturn")," flag to true, which later instructions may branch on to execute the ",(0,l.kt)("inlineCode",{parentName:"li"},"finally"),"\nif necessary, and then return.")),(0,l.kt)("h2",{id:"instruction-semantics"},"Instruction semantics"),(0,l.kt)("p",null,"This section describes the semantic of the instruction that are defined in the\nIR. Please make sure to update this section as new instructions are added to the\ncompiler."),(0,l.kt)("h3",{id:"branchinst"},"BranchInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"BranchInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Jumps to a different basic block.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = BranchInst %BB1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"A single operand which is the target basic block.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"Terminates a basic block and 'jumps' to a different basic block.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write from memory.")))),(0,l.kt)("h3",{id:"returninst"},"ReturnInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ReturnInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Leaves the function and returns a value.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = ReturnInst %17")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"A single operand which is the returned value. Notice the functions that return without an explicit value return the 'undefined' value.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"Terminates a basic block and transfer the control to the caller of the current function.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write from memory.")))),(0,l.kt)("h3",{id:"allocstackinst"},"AllocStackInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"AllocStackInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Allocates a variable on the stack.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = AllocStackInst $name")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"$name is the textual representation of the variable at the sourcecode level.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"AllocStack allocates a variable on the stack. Depending on the implementation of the VM, the variables may be packed into a single frame. AllocStack values may be used by instructions in different functions that represent closures created by the current functions. AllocStack values are used to represent local and captured variables. The AllocStack itself needs to be used directly. It is not possible to save a reference to the reference. The lifetime of the AllocStack may not exceed the lifetime of the allocating function.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write from memory.")))),(0,l.kt)("h3",{id:"loadframeinst"},"LoadFrameInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"LoadFrameInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Loads a value from a variable.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%1 = LoadFrameInst %0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"The variable from which the instruction loads.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The the instruction reads from a variable. The address must be a valid variable.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Reads from memory.")))),(0,l.kt)("h3",{id:"loadstackinst"},"LoadStackInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"LoadStackInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Loads a value from a stack allocated memory pointed by a reference.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%1 = LoadInst %0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"The address from which the instruction loads.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The the instruction reads from memory. The address must be a valid stack address.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Reads from memory.")))),(0,l.kt)("h3",{id:"storeframeinst"},"StoreFrameInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"StoreFrameInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Stores a value to a frame variable.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%1 = StoreFrameInst %value, %variable")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%value is the value to be stored. %address is the reference to the variable where the value will be stored.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The the instruction saves a value to memory. The address must be a valid variable.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Writes to memory.")))),(0,l.kt)("h3",{id:"storestackinst"},"StoreStackInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"StoreStackInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Stores a value to a stack allocated memory.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%1 = StoreStackInst %value, %stack_allocated")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%value is the value to be stored. %address is the reference to stack allocation.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The the instruction saves a value to memory. The address must be a valid stack allocation.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Writes to memory.")))),(0,l.kt)("h3",{id:"asnumberinst"},"AsNumberInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"AsNumberInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Casts a JavaScript value into a number value.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%1 = AsNumberInst %input")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"The value to cast.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction follows the JavaScript rules for converting types into numbers.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read or write to memory.")))),(0,l.kt)("h3",{id:"asint32inst"},"AsInt32Inst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"AsInt32Inst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Casts a JavaScript value into a signed 32-bit integer value.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%1 = AsInt32Inst %input")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"The value to cast.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction follows the JavaScript rules for converting types into 32-bit signed integers.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read or write to memory.")))),(0,l.kt)("h3",{id:"addemptystringinst"},"AddEmptyStringInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"AddEmptyStringInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Convert a value to string as if evaluating ",(0,l.kt)("inlineCode",{parentName:"td"},"value + ''"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%1 = AddEmptyStringInst %input")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"The value to cast.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction follows the JavaScript rules for adding an empty string to a value (ES5.1 11.6.1).")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read or write to memory or throw.")))),(0,l.kt)("h3",{id:"condbranchinst"},"CondBranchInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CondBranchInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Jumps to one of two blocks depending on a condition value.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%1 = CondBranchInst %cond, %BB1, %BB2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%cond is the condition variable, %BB1 is the 'True' block, %BB2 is the 'False' block.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction observes the value of a typed value and jumps to one of two basic blocks. If the condition is evaluated as 'True' the program jumps to the 'True' block. Otherwise the program jumps to the 'False' block.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write from memory.")))),(0,l.kt)("h3",{id:"comparebranchinst"},"CompareBranchInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CompareBranchInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Performs  a binary comparison of the two operands and a conditional branch depending on the result.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = CompareBranch %x, %y, %BB1, %BB2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%x and %y are the operands of the binary operation, %BB1 is the 'True' block, %BB2 is the 'False' block.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction follows the rules of JavaScript for each one of the binary operators defined in the instruction. If the condition is evaluated as 'True' the program jumps to the 'True' block. Otherwise the program jumps to the 'False' block.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory.")))),(0,l.kt)("h3",{id:"createscopeinst"},"CreateScopeInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CreateScopeInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Create a new function top-level scope.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = CreateScopeInst %desc")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%desc describes the function's top-level scope.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"Creates the top-level scope for its function.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write to memory.")))),(0,l.kt)("h3",{id:"createinnerscopeinst"},"CreateInnerScopeInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CreateInnerScopeInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Creates a new scope with the given parent")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = CreateInnerScopeInst %parent, %desc")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%parent is the inner scope's parent scope, and %desc describes the scope that is being created.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"Creates a new inner scope within the given parent.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write to memory.")))),(0,l.kt)("h3",{id:"createfunction"},"CreateFunction"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CreateFunction"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Constructs a new function into the current scope from its code representation.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = CreateFunction %function,")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%function is the function that represents the code of the generated closure.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction creates a new closure that may access the lexical scope of the calling function")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write to memory.")))),(0,l.kt)("h3",{id:"binaryoperatorinst"},"BinaryOperatorInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"BinaryOperatorInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Performs the binary operation on the two operands.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = BinaryOperatorInst %x, %y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%x and %y are the operands of the binary operation.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction follows the rules of JavaScript for each one of the binary operators defined in the instruction.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory.")))),(0,l.kt)("h3",{id:"directevalinst"},"DirectEvalInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"DirectEvalInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Implement a syntactical call to ",(0,l.kt)("inlineCode",{parentName:"td"},"eval(arg)")," where ",(0,l.kt)("inlineCode",{parentName:"td"},"eval")," is global property.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"%0 = DirectEvalInst %value1"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%value1 is the value which will be evaluated.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"Implement the semantics of ES6 ",(0,l.kt)("inlineCode",{parentName:"td"},"PerformEval(%value1, evalRealm, strictCaller=true, direct=true)"),' (ES6 18.2.1.1). Note that we only support "strictCaller=true".')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Unknown")))),(0,l.kt)("h3",{id:"callinst"},"CallInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CallInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Calls another function with some arguments.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = CallInst %callee, %this,  %arg0, %arg1, %arg2, ...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%callee is the function to execute. %this is a reference to the 'this' value. Arguments %arg0 ... %argN are the arguments passed to the function.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction passes the control to the callee, that must be of closure type. The arguments are mapped to the parameters. Unmapped parameters are initialized to 'undefined'.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory.")))),(0,l.kt)("h3",{id:"constructinst"},"ConstructInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ConstructInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Construct a new object with a constructor")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = ConstructInst %constructor, #undefined, %arg0, %arg1, %arg2, ...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%constructor is the constructor function to execute. #undefined is not used. %arg0 ... %argN are the arguments passed to the constructor function.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction performs the steps defined in ES5.1 sec-11.2.2 and sec-13.2.2. It allocates the object and calls the constructor function with the new object and the supplied arguments.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory.")))),(0,l.kt)("h3",{id:"callbuiltininst"},"CallBuiltinInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CallBuiltinInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},'Calls a builtin function passing "undefined" for this')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = CallBuiltinInst %builtinNumber, %undefined, %arg0, %arg1, %arg2, ...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%builtinNumber is the builtin to execute. Arguments %arg0 ... %argN are the arguments passed to the function.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction passes the control to the builtin in a VM-specific way. The arguments are mapped to the parameters. Unmapped parameters are initialized to 'undefined'.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory.")))),(0,l.kt)("h3",{id:"callintrinsicinst"},"CallIntrinsicInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CallIntrinsicInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},'Calls an unsafe compiler intrinsic, passing "undefined" for this')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = CallIntrinsicInst %intrinsicsIndex, %undefined, %arg0, %arg1, %arg2, ...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%intrinsicsIndex is the intrinsic to execute. Arguments %arg0 ... %argN are the arguments passed to the function.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction passes the control to the intrinsics in a VM-specific way. The arguments are mapped to the parameters.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory.")))),(0,l.kt)("h3",{id:"getbuiltinclosureinst"},"GetBuiltinClosureInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"GetBuiltinClosureInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Get a closure of a builtin function")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = GetBuiltinClosureInst %builtinNumber")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%builtinNumber is the builtin to return the closure of.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Reads from memory.")))),(0,l.kt)("h3",{id:"loadpropertyinst"},"LoadPropertyInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"LoadPropertyInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Loads the value of a field from a JavaScript object.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = LoadPropertyInst %object, %property")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%object is the object to load from. %property is the name of the field.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction follows the rules of JavaScript property access in ES5.1 sec 11.2.1. The operation GetValue (ES5.1. sec 8.7.1) is then applied to the returned Reference.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory or throw.")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"TryLoadGlobalPropertyInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Loads the value of an existing field from the global object or throw if it doesn't exist.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = TryLoadGlobalPropertyInst %object, %property")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%object is the global object. %property is the name of the field, which must be a string literal.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"Similar to LoadPropertyInst, but throw if the field doesn't exist.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory or throw.")))),(0,l.kt)("h3",{id:"deletepropertyinst"},"DeletePropertyInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"DeletePropertyInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Deletes the value of a field from a JavaScript object.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = DeletePropertyInst %object, %property")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%object is the object to modify. %property is the name of the field.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction follows the rules of JavaScript property access.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory.")))),(0,l.kt)("h3",{id:"storepropertyinst"},"StorePropertyInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"StorePropertyInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Stores a value to field in a JavaScript object.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%4 = StorePropertyInst %value, %object, %property")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%value is the value to be stored. %object is the object where the field %property will be created or modified.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction follows the rules of JavaScript property access in ES5.1 sec 11.2.1. The operation PutValue (ES5.1. sec 8.7.2) is then applied to the returned Reference.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory or throw.")))),(0,l.kt)("h3",{id:"trystoreglobalpropertyinst"},"TryStoreGlobalPropertyInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"TryStoreGlobalPropertyInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Attempt to store a value into an existing field of the global object and throw if it doesn't exist.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%4 = TryStoreGlobalPropertyInst %value, %object, %property")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%value is the value to be stored. %object is the global object, where the field %property will be stored. %property must be a string literal.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"Similar to StorePropertyInst, but throw if the field doesn't exist.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory or throw.")))),(0,l.kt)("h3",{id:"storeownpropertyinst"},"StoreOwnPropertyInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"StoreOwnPropertyInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Stores a value to an ",(0,l.kt)("em",{parentName:"td"},"own property")," of JavaScript object.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%4 = StoreOwnPropertyInst %value, %object, %property, %enumerable : boolean")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%value is the value to be stored. %object is the object where the field with name %property will be created or modified. %enumerable determines whether a new property will be created as enumerable or not.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction follows the rules of JavaScript ",(0,l.kt)("em",{parentName:"td"},"own")," property access. The property is created or updated in the instance of the object, regardless of whether the same property already exists earlier in the prototype chain.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory.")))),(0,l.kt)("h3",{id:"storenewownpropertyinst"},"StoreNewOwnPropertyInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"StoreNewOwnPropertyInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Create a new ",(0,l.kt)("em",{parentName:"td"},"own property")," in what is known to be a JavaScript object.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"%4 = StoreNewOwnPropertyInst %value, %object, %property, %enumerable : boolean"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"%value")," is the value to be stored. ",(0,l.kt)("em",{parentName:"td"},"%object"),", which must be an object, is where the field with name ",(0,l.kt)("em",{parentName:"td"},"%property")," will be created. ",(0,l.kt)("em",{parentName:"td"},"%property")," must be a string literal, otherwise it is impossible to guarantee that it is new. ",(0,l.kt)("em",{parentName:"td"},"%enumerable")," determines whether the new property will be created as enumerable or not.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction follows the rules of JavaScript ",(0,l.kt)("em",{parentName:"td"},"own")," property access. The property is created in the instance of the object, regardless of whether the same property already exists earlier in the prototype chain.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory.")))),(0,l.kt)("h3",{id:"storegettersetterinst"},"StoreGetterSetterInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"StoreGetterSetterInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Associates a pair of getter and setter with an ",(0,l.kt)("em",{parentName:"td"},"own")," field in a JavaScript object, replacing the previous value.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%4 = StoreGetterSetterInst %getter, %setter, %object, %property, %enumerable")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%getter is a getter accessor, or undefined. %setter is a setter accessor, or undefined. %object is the object where the field %property will be created or modified. %enumerable determines whether a new property will be created as enumerable or not.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction follows the rules of JavaScript property access. The property is created or updated in the instance of the object, regardless of whether the same property already exists earlier in the prototype chain. It replaces both accessors even if one or both of the parameters are undefined.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory.")))),(0,l.kt)("h3",{id:"throwifhasrestrictedglobalpropertyinst"},"ThrowIfHasRestrictedGlobalPropertyInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ThrowIfHasRestrictedGlobalPropertyInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Raises an exception if the given name is a restricted global property.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"ThrowIfHasRestrictedGlobalPropertyInst %name : string")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%name is the name to be checked agains global restricted properties.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"Implements the semantics of ES2023 9.1.1.4.14 followed by a throw if %name is a restricted global property.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Unknown.")))),(0,l.kt)("h3",{id:"allocobjectinst"},"AllocObjectInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"AllocObjectInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Allocates a new JavaScript object on the heap.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"%0 = AllocObjectInst %sizeHint : LiteralNumber, %parent : EmptySentinel or null or Value"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"%sizeHint% indicates that the object will need at least that many property slots. "),"%parent",(0,l.kt)("em",{parentName:"td"}," is the optional parent to create the object with: "),"EmptySentinel",(0,l.kt)("em",{parentName:"td"}," means use "),"Object.prototype",(0,l.kt)("em",{parentName:"td"},", "),"null* means no parent, or otherwise use the specified value.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction creates a new JavaScript object on the heap. If the parent is invalid (not EmptySenyinel, null or object), it is silently ignored.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write to memory.")))),(0,l.kt)("h3",{id:"allocobjectliteralinst"},"AllocObjectLiteralInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"AllocObjectLiteralInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Allocates a new JavaScript object on the heap. During lowering pass it will be lowered to either an AllocObjectInst or a HBCAllocObjectFromBufferInst.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},'%0 = AllocObjectLiteralInst "prop1" : string, 10 : number')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%prop_map is a vector of (Literal",(0,l.kt)("em",{parentName:"td"},", value"),") pairs which represents the properties and their keys in the object literal.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction creates a new JavaScript object on the heap with an initial list of properties.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write to memory.")))),(0,l.kt)("h3",{id:"allocarrayinst"},"AllocArrayInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"AllocArrayInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Allocates a new JavaScript array on the heap.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = AllocArrayInst %sizeHint, %value0, %value1, ...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"sizeHint tells the size of the array that the VM should allocate. It must be equal or larger than the initial list of elements in this instruction. The rest of the values are all literal values as the initial elements of the array. Non-literal values or values after elision will be inserted into the array separately.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction creates a new JavaScript array on the heap with a hinted size and initial list of elements.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write to memory.")))),(0,l.kt)("h3",{id:"createargumentsinst"},"CreateArgumentsInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CreateArgumentsInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Allocates the JavaScript ",(0,l.kt)("inlineCode",{parentName:"td"},"arguments")," array-like object on the heap.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = CreateArgumentsInst")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"None.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction creates the ",(0,l.kt)("inlineCode",{parentName:"td"},"arguments"),' object, populates it with copies of the values of the arguments (according to "strict mode" semantics) and sets ',(0,l.kt)("inlineCode",{parentName:"td"},"arguments.length")," to the number of arguments (",(0,l.kt)("inlineCode",{parentName:"td"},"this")," isn't copied or counted). There should be only one CreateArgumentsInst in a function.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write to memory.")))),(0,l.kt)("h3",{id:"createregexpinst"},"CreateRegExpInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CreateRegExpInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Construct a RegExp object from a regexp literal.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},'%0 = CreateRegExpInst "pattern", "flags"')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"pattern: LiteralString")," and ",(0,l.kt)("inlineCode",{parentName:"td"},"flags: LiteralString"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"It is equivalent to calling ",(0,l.kt)("inlineCode",{parentName:"td"},"RegExp(pattern, flags)"),", except that it calls the built-in constructor, even if ",(0,l.kt)("inlineCode",{parentName:"td"},"RegExp")," has been overridden.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write to memory.")))),(0,l.kt)("h3",{id:"switchinst"},"SwitchInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"SwitchInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"The \u2018switch\u2018 instruction is used to transfer control to one of different places.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = SwitchInst %input, %default, ","[%val0, %block0]",", ","[%val1, %block1]"," ..")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction accepts an input, a default block, and one or more pairs of value-destination values. The value must be a primitive JS type, and the destination must be a basic block within the current function.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The semantic of the instruction is identical to a sequence of 'if' statements that compare the value of the input to each of the case statements. Repeating the same value is not allowed.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory.")))),(0,l.kt)("h3",{id:"getpnamesinst"},"GetPNamesInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"GetPNamesInt"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Generates the property enumerator, which is a collection of registers that hold the state of the enumerator (iterator, object base, index, size, etc).")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = GetPNamesInt  %propertyAddr, %baseAddr, %indexAddr, %sizeAddr, %iteratorAddr, %onEmpty, %onLast")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"The first 5 parameters are addresses (stack allocated addresses) that represent the state of the property enumerator. The last two argument are jump destination for the two cases: empty object and object with some properties.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"This instruction is a terminator instruction and prepares the enumerator for the GetNextPNameInst instruction to consume.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory.")))),(0,l.kt)("h3",{id:"getnextpnameinst"},"GetNextPNameInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"GetNextPNameInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Loads the next property from the object property enumerator.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = GetNextPNameInst %propertyAddr, %baseAddr, %indexAddr, %sizeAddr, %iteratorAddr, %onLast, %onSome")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"The first argument is the destination where the name of the property is written into. The next 4 arguments are the state of the property enumerator. The last two arguments are the destination blocks for: no next property, or some property available.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"This instruction is a terminator instruction that uses the state that was prepared by the GetPNamesInst instruction.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory.")))),(0,l.kt)("h3",{id:"catchinst"},"CatchInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CatchInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"This instruction catches an exception, and returns that exception.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = CatchInst")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"This instruction does not have arguments.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"This instruction will be generated for each catch block and for each finally block. The current exception will be returned. CatchInst can only show up at the beginning of a basic block. The coverage and depth information for the CatchInst will be constructed dynamically later during bytecode generation.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory.")))),(0,l.kt)("h3",{id:"throwinst"},"ThrowInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ThrowInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"This instruction will throw an exception.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = ThrowInst %e")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"This instruction takes one parameter, which is the register that contains the exception value")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"This instruction is a terminator instruction that will transition the control to the CatchInst that covers this instruction with closest scope.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory.")))),(0,l.kt)("h3",{id:"checkhasinstanceinst"},"CheckHasInstanceInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CheckHasInstanceInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Check whether an object has a particular instance.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = CheckHasInstanceInst %check_result, %left, %right, %onTrue, %onFalse")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"This instruction takes 5 parameters: %check_result will be a write-only stack register and holds the check result, %left and %right are the operands of instanceof, and %onTrue and %onFalse are the jump targets in case of check returns true/false.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"This instruction is generated as part of instanceof operator. It checks whether %right could possibly have %left as an instance, and returns the check result. If the checked object is invalid to have the target instance, it will throw an exception. It the check returns false, it jumps to the %jump_label.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read or write memory.")))),(0,l.kt)("h3",{id:"trystartinst"},"TryStartInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"TryStartInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Mark the beginning of the try blocks.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = TryStartInst %catchTargetBlock, %tryBodyBlock")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"This instruction takes 2 arguments: %tryBodyBlock is the block where the body of Try starts, %catchTargetBlock is the basic block that contains the CatchInst which covers this try. Both %tryBodyBlock and %catchTargetBlock are successors of this instruction.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"This is a nop, used only for tracking the beginning of try blocks.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write memory.")))),(0,l.kt)("h3",{id:"tryendinst"},"TryEndInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"TryEndInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Mark the end of the try blocks.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = TryEndInst")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"This instruction does not have arguments.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"This is a nop, used only for tracking the end of try blocks.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Technically this instruction itself does not touch memory, however we mark it as may write to prevent optimizations going pass this instruction.")))),(0,l.kt)("h3",{id:"phiinst"},"PhiInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"PhiInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"This is a Phi node instruction.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = PhiInst %value0, %block0, ","[%value1, %block1]")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"A list of pairs of value and incoming basic block.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The PhiNode needs to have a single entry for each incoming basic block of the block the PHI is located in. The incoming value must dominate the last instruction in the incoming block.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write memory.")))),(0,l.kt)("h3",{id:"movinst"},"MovInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"MovInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"The MOV inst represents a low-level operation of moving one register to another.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = MovInst %value0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"Any value.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The Mov instruction is only valid after Register Allocation in bytecode as we move away from SSA form.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write memory.")))),(0,l.kt)("h3",{id:"implicitmovinst"},"ImplicitMovInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ImplicitMovInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"The ImplicitMov inst represents moving one register to another, except the mov will be performed implicitly by an immediately-subsequent instruction. This is used to express to the optimizer instructions which modify registers other than their destination.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = ImplicitMovInst %value0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"Any value.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The ImplicitMov instruction is only valid after Register Allocation in bytecode as we move away from SSA form.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write memory.")))),(0,l.kt)("h3",{id:"debuggerinst"},"DebuggerInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"DebuggerInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"This instruction corresponds to the JavaScript ",(0,l.kt)("inlineCode",{parentName:"td"},"debugger")," statement.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = DebuggerInst")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"It takes no arguments and returns no values.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"Its behavior is implementation-dependent.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write to memory.")))),(0,l.kt)("h3",{id:"getnewtargetinst"},"GetNewTargetInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"GetNewTargetInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Obtains the value of ",(0,l.kt)("inlineCode",{parentName:"td"},"new.target")," in the current function or constructor.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = GetNewTargetInst")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"None")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"It must only be called from a ES6 class constructor or ES5 function. If the callee was invoked from ",(0,l.kt)("inlineCode",{parentName:"td"},"new"),", it returns the function object of the direct constructor, otherwise ",(0,l.kt)("inlineCode",{parentName:"td"},"undefined"),".")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write memory")))),(0,l.kt)("h3",{id:"throwifemptyinst"},"ThrowIfEmptyInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ThrowIfEmptyInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},'Check whether the value is "empty", and if it is, throw ReferenceError, otherwise return it.')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%_ = ThrowIfEmptyInst %value")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"The value to check.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"It is used to implement ES6 TDZ functionality. Variables declared with ",(0,l.kt)("inlineCode",{parentName:"td"},"let")," are ",(0,l.kt)("em",{parentName:"td"},"poisoned")," with ",(0,l.kt)("em",{parentName:"td"},"empty")," until they are initialized.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Potentially throws an exception. Has no other side effects.")))),(0,l.kt)("h3",{id:"coercethisns"},"CoerceThisNS"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CoerceThisNS"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},'Coerces its argument using the rules of "this" coercion to object in non-strict mode.')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = CoerceThisNS %value0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"Any value.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write memory (it potentially creates a new object)")))),(0,l.kt)("h3",{id:"creategenerator"},"CreateGenerator"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CreateGenerator"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Constructs a new GeneratorInnerFunction from its code representation, and wraps it in a Generator object.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = CreateGenerator %function,")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%function is the function that represents the code of the generator's inner function.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"Creates a new GeneratorInnerFunction closure that may access the environment and wraps it in a generator")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write to memory (creates a new object).")))),(0,l.kt)("h3",{id:"startgenerator"},"StartGenerator"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"StartGenerator"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Jump to the proper first instruction to execute in a GeneratorInnerFunction")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = StartGenerator")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"None")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},'Jumps to a BasicBlock which begins with a ResumeGenerator and sets the internal generator state to "executing", but does not handle next(), return(), or throw() as requested by the user.')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Reads and writes memory. Restores the stack based on saved state, and jumps to another BasicBlock")))),(0,l.kt)("h3",{id:"saveandyield"},"SaveAndYield"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"SaveAndYield"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Saves information needed to resume generator execution and yield.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = SaveAndYield %value, %next")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%value is the value to yield, %next is the next BasicBlock to execute upon resuming, which must begin with a ResumeGeneratorInst (generated alongside SaveAndYield).")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"Saves the frame variables and the next IP to the closure, and yield execution.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Reads and writes to memory, may throw or execute.")))),(0,l.kt)("h3",{id:"resumegenerator"},"ResumeGenerator"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ResumeGenerator"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Perform the user-requested action on resuming a generator.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = ResumeGenerator %isReturn")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%isReturn is an output argument set to true if the user requested a return, false otherwise.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"If the user requested next(), continue on. If the user requested throw(), throw. If the user requested return(), set %isReturn to true and continue. Subsequent instructions will check %isReturn and execute any ",(0,l.kt)("inlineCode",{parentName:"td"},"finally")," handlers, for example, before returning.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory. (may throw)")))),(0,l.kt)("h3",{id:"iteratorbegin"},"IteratorBegin"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"IteratorBegin"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Begins array destructuring on a given iterable source.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = IteratorBegin %sourceOrNext")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%sourceOrNext","[in/out]"," is the stack location for source to destructure from. Is set to source if performing array iteration, else set to the ",(0,l.kt)("inlineCode",{parentName:"td"},".next()")," method of the iterator.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"If %sourceOrNext is an Array then it remains unmodified and the instruction returns ",(0,l.kt)("inlineCode",{parentName:"td"},"0"),", but if it is not, it is replaced with the 'next' method so that it can be called on each step of the iteration and the instruction returns the iterator object. If the ",(0,l.kt)("inlineCode",{parentName:"td"},"[Symbol.iterator]")," function throws, this instruction will throw.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory, may throw or execute.")))),(0,l.kt)("h3",{id:"iteratornext"},"IteratorNext"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"IteratorNext"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Destructures the next value from a given iterator.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = IteratorNext %iterator %sourceOrNext")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%iterator is the index or the iterator. %sourceOrNext is the input stack location (source to destructure from) or the next method.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"If %iterator is an index: if %iterator is less than ",(0,l.kt)("inlineCode",{parentName:"td"},"%sourceOrNext.length"),", reads the value from %sourceOrNext and increments the index, else sets %iterator to undefined and returns undefined. If %iterator is an actual iterator, calls %sourceOrNext as a next method and evaluates to the result value. When iteration is complete, sets %iterator to undefined as a signal that we're done.")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"if (typeof %iterator === 'undefined') {\n  return undefined;\n}\nif (typeof %iterator === 'number') {\n  if (%iterator >= %sourceOrNext.length) {\n    %iterator = undefined;\n    return undefined;\n  }\n  return %sourceOrNext[%iterator];\n}\nvar iterResult = %sourceOrNext();\nif (iterResult.done) {\n  %iterator = undefined;\n  return undefined;\n}\nreturn iterResult.value;\n")),(0,l.kt)("p",null,"Effects | May read and write memory, may throw or execute."),(0,l.kt)("h3",{id:"iteratorclose"},"IteratorClose"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"IteratorClose"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Closes an iterator if it exists.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = IteratorClose %iterator %ignoreInnerException")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%iterator is the index or the iterator. %ignoreInnerException is a boolean literal.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"If %iterator is an iterator, calls ",(0,l.kt)("inlineCode",{parentName:"td"},".return()")," on it to close it. Otherwise, this is a no-op. If ",(0,l.kt)("inlineCode",{parentName:"td"},".return()")," throws, the exception is ignored when %ignoreInnerException is true.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory, may throw or execute.")))),(0,l.kt)("h3",{id:"unreachableinst"},"UnreachableInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"UnreachableInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Crashes the VM (ifndef NDEBUG).")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = UnreachableInst")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"None.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"Can be added to stubs and similar to verify that they are never executed.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Marked as reading/writing memory to avoid reordering.")))),(0,l.kt)("h2",{id:"target-instructions"},"Target Instructions"),(0,l.kt)("p",null,"Some high-level IR instructions are lowered into a sequence of low-level machine\ninstructions. In order to perform register allocation on these instructions we\nneed to perform lowering, which is a form of instruction selection. The semantic\nof these instructions are identical to the semantic of the relevant target\ninstructions."),(0,l.kt)("h3",{id:"hbcgetglobalobjectinst"},"HBCGetGlobalObjectInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"HBCGetGlobalObjectInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},'Obtain the "global" object')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = HBCGetGlobalObjectInst")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"None.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},'The instruction returns a reference to the "global" object.')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write to memory.")))),(0,l.kt)("h3",{id:"hbccreateenvironment"},"HBCCreateEnvironment"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"HBCCreateEnvironment"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Create a new function top-level environment.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = HBCCreateEnvironment %desc")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%desc describes the function's top-level environment.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"Creates the top-level environment for its function.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write to memory.")))),(0,l.kt)("h3",{id:"hbccreateinnerenvironment"},"HBCCreateInnerEnvironment"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"HBCCreateInnerEnvironment"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Creates a new environment with the given parent")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = HBCCreateInnerEnvironment %parent, %desc")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%parent is the inner environment's parent environment, and %desc describes the environment that is being created.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"Creates a new inner environment within the given parent.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write to memory.")))),(0,l.kt)("h3",{id:"hbccreatefunction"},"HBCCreateFunction"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"HBCCreateFunction"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Create a new closure capturing the specified environment and using the specified body")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = HBCCreateFunction %environment, %body,")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%environment is the closure's environment. %body is the closure's body.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction creates a new closure that may access the specified environment.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write to memory.")))),(0,l.kt)("h3",{id:"hbccreategenerator"},"HBCCreateGenerator"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"CreateGenerator"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Constructs a new Generator into the current scope from its code representation.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = CreateGenerator %environment, %body,")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%environment is the closure's environment, %body is the closure's body.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction creates a new GeneratorInnerFunction access the environment and wraps it in a Generator.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write to memory.")))),(0,l.kt)("h3",{id:"hbcallocobjectfrombufferinst"},"HBCAllocObjectFromBufferInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"HBCAllocObjectFromBufferInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Allocates a new JavaScript object on the heap, and initializes it with values from the object buffer.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = HBCAllocObjectFromBufferInst %value0, %value1, ...")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"The values are all literal values, with alternating keys and values. Non-literal values will be inserted into the array separately.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction creates a new JavaScript object on the heap with an initial list of properties.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not read or write to memory.")))),(0,l.kt)("h3",{id:"hbccallninst"},"HBCCallNInst"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"HBCCallNInst"),(0,l.kt)("th",{parentName:"tr",align:null},"_"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Description"),(0,l.kt)("td",{parentName:"tr",align:null},"Calls a function with a fixed number of arguments (from 1 to 4, inclusive).")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Example"),(0,l.kt)("td",{parentName:"tr",align:null},"%0 = HBCCallNInst %callee, %this, %arg0, %arg1, %arg2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arguments"),(0,l.kt)("td",{parentName:"tr",align:null},"%callee is the function to execute. %this is a reference to the 'this' value. Arguments %arg0 ... %argN are the arguments passed to the function.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,l.kt)("td",{parentName:"tr",align:null},"The instruction copies its arguments (starting from this) into the parameter-passing registers at the end of the frame, and passes the control to the callee, which must be of closure type. The arguments are mapped to the parameters. Unmapped parameters are initialized to 'undefined'.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Effects"),(0,l.kt)("td",{parentName:"tr",align:null},"May read and write memory.")))))}c.isMDXComponent=!0}}]);