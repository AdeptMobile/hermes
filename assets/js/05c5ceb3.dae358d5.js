"use strict";(self.webpackChunkhermes_website=self.webpackChunkhermes_website||[]).push([[937],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),d=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return i.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=d(n),c=a,h=u["".concat(s,".").concat(c)]||u[c]||m[c]||r;return n?i.createElement(h,o(o({ref:t},p),{},{components:n})):i.createElement(h,o({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,o[1]=l;for(var d=2;d<r;d++)o[d]=n[d];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4961:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return u}});var i=n(3117),a=n(102),r=(n(7294),n(3905)),o=["components"],l={id:"modules",title:"Modules"},s=void 0,d={unversionedId:"modules",id:"modules",title:"Modules",description:"In which we describe the module system and metadata input.",source:"@site/../doc/Modules.md",sourceDirName:".",slug:"/modules",permalink:"/docs/modules",draft:!1,editUrl:"https://github.com/facebook/hermes/blob/HEAD/website/../doc/Modules.md",tags:[],version:"current",lastUpdatedAt:1607758573,formattedLastUpdatedAt:"Dec 12, 2020",frontMatter:{id:"modules",title:"Modules"},sidebar:"docs",previous:{title:"The Hades Garbage Collector",permalink:"/docs/hades"},next:{title:"Strings",permalink:"/docs/strings"}},p={},u=[{value:"Metadata Format",id:"metadata-format",level:3},{value:"Example Metadata File",id:"example-metadata-file",level:4},{value:"Require system",id:"require-system",level:3},{value:"Source maps",id:"source-maps",level:3},{value:"Complete design",id:"complete-design",level:3}],m={toc:u},c="wrapper";function h(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)(c,(0,i.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In which we describe the module system and metadata input."),(0,r.kt)("h3",{id:"metadata-format"},"Metadata Format"),(0,r.kt)("p",null,"In order to provide a directory or zipfile to Hermes,\nit must contain a ",(0,r.kt)("inlineCode",{parentName:"p"},"metadata.json")," file at the root."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"metadata.json")," file must be a JSON object, with the following fields:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"segments"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},'An object with string keys representing integers, which are the segments\nIDs. The IDs are generally sequential but there can be gaps (ex. having IDs\n"6" and "8" and no "7"). ID zero has special meaning, this is the "main\nsegment" that gets loaded on startup (ex. when React Native starts).'),(0,r.kt)("li",{parentName:"ul"},"Each value must be an array containing file paths\nof the files to place into that segment, expressed relative to the root of\nthe ZIP file (ex. ",(0,r.kt)("inlineCode",{parentName:"li"},"subdir/foo.js"),"). File paths may include ",(0,r.kt)("inlineCode",{parentName:"li"},"./")," at the start,\nbut they are not required to."),(0,r.kt)("li",{parentName:"ul"},"The first element of ",(0,r.kt)("inlineCode",{parentName:"li"},'segments["0"]')," is the first module ",(0,r.kt)("inlineCode",{parentName:"li"},"require"),"d at run time."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"resolutionTable")," (Optional)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"An object for which the keys are relative file names\n(the same file names as in ",(0,r.kt)("inlineCode",{parentName:"li"},"segments"),")."),(0,r.kt)("li",{parentName:"ul"},"Values are objects which map from strings given to ",(0,r.kt)("inlineCode",{parentName:"li"},"require()"),"\nto their actual resolved file path relative to the directory or zip file root.\nThese relative paths should be the same as in ",(0,r.kt)("inlineCode",{parentName:"li"},"segments"),", with leading ",(0,r.kt)("inlineCode",{parentName:"li"},"./"),".")))),(0,r.kt)("h4",{id:"example-metadata-file"},"Example Metadata File"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'{\n  "segments": {\n    "0": [\n      "./cjs-subdir-main.js",\n      "cjs-subdir-2.js",\n      "bar/cjs-subdir-bar.js",\n      "foo/cjs-subdir-foo.js"\n    ]\n  },\n  "resolutionTable": {\n    "./cjs-subdir-main.js": {\n      "foo": "./foo/cjs-subdir-foo.js"\n    },\n    "./foo/cjs-subdir-foo.js": {\n      "bar": "./bar/cjs-subdir-bar.js"\n    }\n  }\n}\n')),(0,r.kt)("h3",{id:"require-system"},"Require system"),(0,r.kt)("p",null,"Modules can require each other using the ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," function provided as a local\nvariable by the runtime. The argument to ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," must be an absolute path\nwhich root is the root of the ZIP file or input directory. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const Foo = require('/subdir/foo.js');\n\nFoo.doSmth();\n")),(0,r.kt)("h3",{id:"source-maps"},"Source maps"),(0,r.kt)("p",null,"Each JavaScript file can optionally provide a corresponding source map, which is\nthe name of the source file with the suffix ",(0,r.kt)("inlineCode",{parentName:"p"},".map"),". For example ",(0,r.kt)("inlineCode",{parentName:"p"},"subdir/foo.js"),"\nmight provide a ",(0,r.kt)("inlineCode",{parentName:"p"},"subdir/foo.js.map")," file."),(0,r.kt)("h3",{id:"complete-design"},"Complete design"),(0,r.kt)("p",null,"Module mode is currently activated via passing ",(0,r.kt)("inlineCode",{parentName:"p"},"-commonjs")," to Hermes while compiling.\nHermes can then be given a directory and a ",(0,r.kt)("inlineCode",{parentName:"p"},"metadata.json")," file,\nor a simple list of files with the first being the entry point."),(0,r.kt)("p",null,"First, each file is parsed just like any other JS file.\nThen, a call to ",(0,r.kt)("inlineCode",{parentName:"p"},"hermes::wrapCJSModule"),' puts each file in its own "module function",\nwhich binds ',(0,r.kt)("inlineCode",{parentName:"p"},"exports, require, module")," as parameters."),(0,r.kt)("p",null,"IR generation relies on this wrapping of the AST.\nEvery CJS module file generates IR into a shared ",(0,r.kt)("inlineCode",{parentName:"p"},"hermes::Module"),"\n(it's called ",(0,r.kt)("inlineCode",{parentName:"p"},"M")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"generateIRForSourcesAsCJSModules"),").\nEach of these generated CJS modules are now ",(0,r.kt)("inlineCode",{parentName:"p"},"hermes::Function *"),"s.\nThese are registered in the ",(0,r.kt)("inlineCode",{parentName:"p"},"cjsModules_")," field using the ",(0,r.kt)("inlineCode",{parentName:"p"},"hermes::Module::addCJSModule")," function,\nwhich stores information in the ",(0,r.kt)("inlineCode",{parentName:"p"},"CJSModule")," struct regarding filename, id, and IR function.\nThis allows lookup of the CJS modules either via ",(0,r.kt)("inlineCode",{parentName:"p"},"hermes::Function *")," or by string literal (file path)."),(0,r.kt)("p",null,"If the caller of the Hermes CLI passes ",(0,r.kt)("inlineCode",{parentName:"p"},"-static-require"),",\nthen we attempt to resolve all ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," calls at compilation time.\nThis occurs in ",(0,r.kt)("inlineCode",{parentName:"p"},"ResolveStaticRequire.cpp"),", which is able to resolve files if they were povided\nby the user at invocation time and if all ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," calls only take string literals as arguments.\nIf every ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," call is able to be resolved, every one of these ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," calls is replaced\nwith a call to ",(0,r.kt)("inlineCode",{parentName:"p"},"HermesBuiltin_requireFast")," with an ID for the CJS module,\nand that function does no string work and is therefore very fast."),(0,r.kt)("p",null,"After all CJS modules have generated IR and all the ",(0,r.kt)("inlineCode",{parentName:"p"},"require"),"s have been resolved,\nwe generate one or more bytecode files from our ",(0,r.kt)("inlineCode",{parentName:"p"},"IR::Module M"),".\nThis requires two special bits of logic in ",(0,r.kt)("inlineCode",{parentName:"p"},"hbc::generateBytecodeModule"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We add a mapping from a CJS module to the HBC function ID.\nThis allows us to actually run ",(0,r.kt)("inlineCode",{parentName:"li"},"require")," when JS execution demands it.\nIf ",(0,r.kt)("inlineCode",{parentName:"li"},"require"),"s have been resolved, we add to the ",(0,r.kt)("inlineCode",{parentName:"li"},"cjsModulesStatic_")," table in the HBC file,\nelse we add to to the ",(0,r.kt)("inlineCode",{parentName:"li"},"cjsModules_")," table in the HBC file (which maps from strings instead of IDs)."),(0,r.kt)("li",{parentName:"ul"},"To accommodate bundle splitting, we also pass a ",(0,r.kt)("inlineCode",{parentName:"li"},"SegmentRange")," to the function.\nThis allows us to only compile the functions which are needed by the CJS modules in the segment.\nWe then set a ",(0,r.kt)("inlineCode",{parentName:"li"},"cjsModuleOffset_")," field in the HBC file,\nwhich allows us to know how far into the complete set of CJS modules this segment is.\n",(0,r.kt)("strong",{parentName:"li"},"Because every HBC file contains a contiguous set of CJS modules, each of which are unique,\nit is not possible for multiple segments to contain the same CJS module."))),(0,r.kt)("p",null,"Having built 1 or more HBC files in the compiler, we can now execute them.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"vm::Domain")," data structure is used for keeping track of all HBC files which were compiled together.\nIn particular, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Domain")," owns a CJS module table.\nThis table is an array of CJS modules, indexed by the CJS module's ID.\nIf ",(0,r.kt)("inlineCode",{parentName:"p"},"require"),"s were not resolved at compile time, there's also a mapping from file path to that ID."),(0,r.kt)("p",null,"The first HBC file to be loaded must have a ",(0,r.kt)("inlineCode",{parentName:"p"},"cjsModuleOffset_")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),".\nCJSModule ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," is the entry point, and will be executed first.\nLoading of other segments is then done via a ",(0,r.kt)("inlineCode",{parentName:"p"},"loadSegment")," call in the runtime;\nthe user can call it via the ConsoleHost ",(0,r.kt)("inlineCode",{parentName:"p"},"loadSegment")," or more commonly via the Hermes API.\n",(0,r.kt)("inlineCode",{parentName:"p"},"loadSegment")," does need a ",(0,r.kt)("inlineCode",{parentName:"p"},"requireContext"),", which allows us to determine which ",(0,r.kt)("inlineCode",{parentName:"p"},"Domain")," to actually\nload the new CJS modules from the segment into.\nThis is registered into ",(0,r.kt)("inlineCode",{parentName:"p"},"require.context")," (recall that ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," was bound as a param in all CJS modules)."),(0,r.kt)("p",null,"Finally, we can ",(0,r.kt)("inlineCode",{parentName:"p"},"require"),".\nWhen ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," is called, one of two things happens:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If we DID resolve all static ",(0,r.kt)("inlineCode",{parentName:"li"},"require"),"s, then calls to ",(0,r.kt)("inlineCode",{parentName:"li"},"require")," were turned into Hermes builtin\ncalls, so the actual value of ",(0,r.kt)("inlineCode",{parentName:"li"},"require"),"s (the parameter) is not used.\nWe simply call ",(0,r.kt)("inlineCode",{parentName:"li"},"HermesBuiltin_requireFast")," via the ",(0,r.kt)("inlineCode",{parentName:"li"},"CallBuiltin")," instruction."),(0,r.kt)("li",{parentName:"ul"},"If we DID NOT resolve all static ",(0,r.kt)("inlineCode",{parentName:"li"},"require"),"s, we call the ",(0,r.kt)("inlineCode",{parentName:"li"},"require")," function.\nThe runtime will have set up that function to also pass along the base path (to allow relative ",(0,r.kt)("inlineCode",{parentName:"li"},"require"),"),\nso ",(0,r.kt)("inlineCode",{parentName:"li"},"require")," is now a BoundFunction (as if we'd done ",(0,r.kt)("inlineCode",{parentName:"li"},"require = require.bind(currentPath)"),").\nNote that this is transparent to the application developer, and doesn't change the way ",(0,r.kt)("inlineCode",{parentName:"li"},"require"),"\nis actually called in JS source.\nIn either case, we do ",(0,r.kt)("inlineCode",{parentName:"li"},"runRequireCall")," as implemented in ",(0,r.kt)("inlineCode",{parentName:"li"},"require.cpp"),".\nIt performs any necessary checks, calls the target CJS module, and caches and reads ",(0,r.kt)("inlineCode",{parentName:"li"},"exports")," back.")),(0,r.kt)("p",null,"Hermes also partially supports ECMAScript modules.\nCurrently, the interop of ESM and CJS modules is defined simply by turning ",(0,r.kt)("inlineCode",{parentName:"p"},"import")," into ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," calls.\nThis precludes full correctness of the ESM module system, which requires ",(0,r.kt)("em",{parentName:"p"},"live bindings"),";\nwhen a value is changed in the imported module, the local binding to that value must also be updated.\nTests for the current emitted code can be found in ",(0,r.kt)("inlineCode",{parentName:"p"},"test/hermes/esm/"),"."))}h.isMDXComponent=!0}}]);