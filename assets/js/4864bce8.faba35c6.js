(self.webpackChunkhermes_website=self.webpackChunkhermes_website||[]).push([[195],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return d},kt:function(){return m}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(t),m=i,h=u["".concat(s,".").concat(m)]||u[m]||c[m]||r;return t?a.createElement(h,o(o({ref:n},d),{},{components:t})):a.createElement(h,o({ref:n},d))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},2477:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return o},metadata:function(){return l},toc:function(){return s},default:function(){return d}});var a=t(4034),i=t(9973),r=(t(7294),t(3905)),o={id:"vm",title:"VM Overview"},l={unversionedId:"vm",id:"vm",isDocsHomePage:!1,title:"VM Overview",description:"Value Representation",source:"@site/../doc/VM.md",sourceDirName:".",slug:"/vm",permalink:"/docs/vm",editUrl:"https://github.com/facebook/hermes/blob/HEAD/website/../doc/VM.md",version:"current",lastUpdatedAt:1624441662,formattedLastUpdatedAt:"6/23/2021",frontMatter:{id:"vm",title:"VM Overview"},sidebar:"docs",previous:{title:"Design of the Optimizer",permalink:"/docs/optimizer"},next:{title:"The GenGC Garbage Collector",permalink:"/docs/gengc"}},s=[{value:"Value Representation",id:"value-representation",children:[{value:"HermesValue",id:"hermesvalue",children:[]},{value:"HermesValue32",id:"hermesvalue32",children:[]},{value:"Strings",id:"strings",children:[]}]},{value:"Runtime",id:"runtime",children:[{value:"Runtime Module",id:"runtime-module",children:[]},{value:"Runtime Identifiers",id:"runtime-identifiers",children:[]},{value:"Garbage Collection",id:"garbage-collection",children:[]}]},{value:"Object Model",id:"object-model",children:[{value:"Objects",id:"objects",children:[]},{value:"Arrays",id:"arrays",children:[]},{value:"Functions",id:"functions",children:[]},{value:"Boxed Primitives",id:"boxed-primitives",children:[]}]},{value:"REPL",id:"repl",children:[]}],p={toc:s};function d(e){var n=e.components,t=(0,i.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"value-representation"},"Value Representation"),(0,r.kt)("h3",{id:"hermesvalue"},"HermesValue"),(0,r.kt)("p",null,"The VM uses a class called ",(0,r.kt)("inlineCode",{parentName:"p"},"HermesValue")," to encapsulate JS values efficiently,\npreserving their type while still allowing them to fit in a register.\nNaN-tagging is used to store different types of values;\nwe store values in the lower bits of a ",(0,r.kt)("inlineCode",{parentName:"p"},"uint64_t"),".\nThus, when the ",(0,r.kt)("inlineCode",{parentName:"p"},"uint64_t")," is interpreted as a ",(0,r.kt)("inlineCode",{parentName:"p"},"double"),",\ntagged ",(0,r.kt)("inlineCode",{parentName:"p"},"NaN")," values can hold non-",(0,r.kt)("inlineCode",{parentName:"p"},"double")," types."),(0,r.kt)("p",null,"After we reserve the canonical quiet NaN to be used as the NaN representation\nin the VM, we have 51 remaining bits we can set. Even on 64-bit systems, we are\nable to accommodate a full pointer and type tag, since pointers are never more\nthan 48 bits in practice."),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"HermesValue")," can take on any of the following types of values, which are\ndistinguished by their type tag:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Empty"),(0,r.kt)("li",{parentName:"ol"},"Undefined"),(0,r.kt)("li",{parentName:"ol"},"Null"),(0,r.kt)("li",{parentName:"ol"},"Boolean"),(0,r.kt)("li",{parentName:"ol"},"Symbol"),(0,r.kt)("li",{parentName:"ol"},"Native value (used to store an int or pointer for bookkeeping)"),(0,r.kt)("li",{parentName:"ol"},"String pointer"),(0,r.kt)("li",{parentName:"ol"},"Object pointer")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"HermesValue")," is used across the VM to store and pass JS values.\n",(0,r.kt)("inlineCode",{parentName:"p"},"PinnedHermesValue")," is used in non-moveable memory, primarily for the register\nstack and other GC roots in known locations in memory. ",(0,r.kt)("inlineCode",{parentName:"p"},"GCHermesValue"),"s are\nused on the GC managed heap."),(0,r.kt)("h3",{id:"hermesvalue32"},"HermesValue32"),(0,r.kt)("p",null,"When compressed pointers are enabled, we also encode some values in a compact\n32-bit representation called ",(0,r.kt)("inlineCode",{parentName:"p"},"HermesValue32"),". Because compressing pointers to\nstore in this format requires additional work, we also avoid using\n",(0,r.kt)("inlineCode",{parentName:"p"},"HermesValue32")," for frequently accessed values (like the register stack).\nInstead we selectively use ",(0,r.kt)("inlineCode",{parentName:"p"},"HermesValue32")," for objects that are known to\nconsume a large percentage of heap memory, but that are unlikely to affect\nperformance."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"HermesValue32")," supports storing all of the types that ",(0,r.kt)("inlineCode",{parentName:"p"},"HermesValue")," does,\nexcept for native values, which were dropped because they are relatively rare\nand because we do not have a mechanism for compressing native pointers outside\nthe GC managed heap."),(0,r.kt)("p",null,"Instead of using NaN boxing, it takes advantage of the 8-byte alignment of the\nHermes heap to store tags, since the lowest 3 bits of a pointer are always\nguaranteed to be zero (even after compression)."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"HermesValue32")," also requires special handling for doubles. It is able to store\nsmall integers up to 29 bits inline, but anything that cannot be represented in\nthat form must be stored as a separate double object on the heap. Based on the\nworkloads we have looked at, actual doubles are very rarely used, so the\noverhead of this approach is small."),(0,r.kt)("h3",{id:"strings"},"Strings"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"StringPrimitive")," is used to store immutable UTF16 encoded strings,\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"StringPrimitive *")," can be stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"HermesValue")," to make JS String values."),(0,r.kt)("p",null,"Internally, ",(0,r.kt)("inlineCode",{parentName:"p"},"StringPrimitive")," can be"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DynamicStringPrimitive")," (stored in the GC heap)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ExternalStringPrimitive")," (stored as a pointer outside the VM, such as into a bytecode file)")),(0,r.kt)("h2",{id:"runtime"},"Runtime"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Runtime")," class is the primary driver of the VM.\nIt contains the current environment and heap, as well as the code to execute.\n",(0,r.kt)("inlineCode",{parentName:"p"},"Runtime")," is used to execute ",(0,r.kt)("inlineCode",{parentName:"p"},"RuntimeModule"),"s,\nwhich are constructed from ",(0,r.kt)("inlineCode",{parentName:"p"},"BytecodeModule"),"s using ",(0,r.kt)("inlineCode",{parentName:"p"},"Runtime::runModule()"),"."),(0,r.kt)("h3",{id:"runtime-module"},"Runtime Module"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"RuntimeModule")," is the VM representation into a bytecode file.\n",(0,r.kt)("inlineCode",{parentName:"p"},"RuntimeModule"),"s are stored outside the GC heap and are constructed via ",(0,r.kt)("inlineCode",{parentName:"p"},"new"),"."),(0,r.kt)("p",null,"To allow for segmentation of bytecode files and ",(0,r.kt)("inlineCode",{parentName:"p"},"require"),"ing modules between\nseparate segments, we collect ",(0,r.kt)("inlineCode",{parentName:"p"},"RuntimeModule"),"s in a class called ",(0,r.kt)("inlineCode",{parentName:"p"},"Domain"),".\nYou may think of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Domain")," as the collection of bytecode files which were\nall compiled in the same invocation of the compiler."),(0,r.kt)("p",null,"Every ",(0,r.kt)("inlineCode",{parentName:"p"},"JSFunction")," shares ownership of a ",(0,r.kt)("inlineCode",{parentName:"p"},"Domain"),", and the ",(0,r.kt)("inlineCode",{parentName:"p"},"Domain")," owns\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"RuntimeModule"),"s which provide those functions. In this way, when all\n",(0,r.kt)("inlineCode",{parentName:"p"},"JSFunction"),"s which require the files in a ",(0,r.kt)("inlineCode",{parentName:"p"},"Domain")," are collected,\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"Domain")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"RuntimeModule"),"s are also collected."),(0,r.kt)("h3",{id:"runtime-identifiers"},"Runtime Identifiers"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Runtime")," contains an ",(0,r.kt)("inlineCode",{parentName:"p"},"IdentifierTable"),",\nwhich is used for getting unique IDs for strings.\nThe table is used to go from ",(0,r.kt)("inlineCode",{parentName:"p"},"StringPrimitive")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"SymbolID"),' and back.\nIt\'s prepopulated with some "predefined strings",\nthe set of strings that are required by built in functions,\nwhich can be seen in ',(0,r.kt)("inlineCode",{parentName:"p"},"PredefinedStrings.def"),"."),(0,r.kt)("h3",{id:"garbage-collection"},"Garbage Collection"),(0,r.kt)("p",null,"Currently, the VM uses ",(0,r.kt)("inlineCode",{parentName:"p"},"HadesGC")," by default, a concurrent garbage collector aimed at dramatically lowering pause times over our previous collector ",(0,r.kt)("a",{parentName:"p",href:"/docs/gengc"},"GenGC"),". The heap in Hermes is non-contiguous, which allows us to avoid reserving large regions of address space upfront, and allows us to return memory to the OS at a finer granularity. Garbage collection in Hermes is precise, which means that the GC always knows which values contain valid pointers."),(0,r.kt)("p",null,"See the documentation for ",(0,r.kt)("a",{parentName:"p",href:"/docs/hades"},"Hades")," for details\non how it works."),(0,r.kt)("p",null,"The garbage collector moves objects to different place on the heap,\ninvalidating ",(0,r.kt)("inlineCode",{parentName:"p"},"HermesValue"),"s,\nso there are a couple classes which allow updating them automatically.\n",(0,r.kt)("inlineCode",{parentName:"p"},"Handle<>")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Handle<T>")," are garbage collector-aware handles;\nthey are moved if a collection occurs in between two successive accesses.\nSo, to ensure correctness in the VM,\nuse the handles instead of passing raw ",(0,r.kt)("inlineCode",{parentName:"p"},"HermesValue")," between functions."),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"GCScope")," is used to keep track of all the current ",(0,r.kt)("inlineCode",{parentName:"p"},"HermesValue")," handles.\nAny ",(0,r.kt)("inlineCode",{parentName:"p"},"GCScope")," must be constructed on the stack,\nwhence it tracks any scoped handles that are used until it falls out of scope.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"GCScope")," allocates space in chunks,\nand when it is destroyed (falls out of scope) it frees any chunks it allocated.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"GCScope")," is used to internally generate ",(0,r.kt)("inlineCode",{parentName:"p"},"PinnedHermesValue"),"s,\nwhich are then stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"Handle<>")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Handle<T>"),"."),(0,r.kt)("p",null,"We also provide ",(0,r.kt)("inlineCode",{parentName:"p"},"PseudoHandle<T>")," classes which are explicitly ",(0,r.kt)("em",{parentName:"p"},"not")," handles.\nThese are used to be explicit about storage of raw pointers and ",(0,r.kt)("inlineCode",{parentName:"p"},"HermesValue"),".\n",(0,r.kt)("inlineCode",{parentName:"p"},"PseudoHandle")," should be used as an argument in place of a raw pointer to\nfunctions which may want to turn that argument into a ",(0,r.kt)("inlineCode",{parentName:"p"},"Handle"),",\nbut in which it's not necessary to ",(0,r.kt)("em",{parentName:"p"},"always")," incur the cost of handle allocation.\n",(0,r.kt)("inlineCode",{parentName:"p"},"PseudoHandle")," also does not have a copy constructor,\nand moving out of one invalidates it.\nThis prevents the reuse of ",(0,r.kt)("inlineCode",{parentName:"p"},"PseudoHandle")," after an allocating function call."),(0,r.kt)("h4",{id:"rules-for-using-handles"},"Rules for using handles"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A function that can perform an allocation (even if it doesn't do it every\ntime) or calls a function that does, must accept and return only handles\n(for GC-managed objects). It must also take a ",(0,r.kt)("inlineCode",{parentName:"li"},"Runtime*")," as an argument."),(0,r.kt)("li",{parentName:"ol"},"A function that accepts or returns handles is allowed (and can be assumed\nto) allocate more handles, but the upper bound of allocated handles must be\nstatic."),(0,r.kt)("li",{parentName:"ol"},"The number of handles in a given GCScope should have a static upper limit.")),(0,r.kt)("p",null,"The motivation for these rules should be self-explanatory.  The practical\nimplication of rule 2 and 3 is that recursion and loops that allocate handles\nin every iteration must be treated specially.  In case of recursion a new\nGCScope should be defined in each recurrence (is that the correct term?).  In\ncase of a loop, there are a couple of possibilities:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"in loops that are expected to be low iteration and not performance critical,\na new GCScope can be defined in the body of the loop."),(0,r.kt)("li",{parentName:"ul"},"otherwise a GCScope::Marker should be used to flush the allocated handles of\nthe previous iteration."),(0,r.kt)("li",{parentName:"ul"},"mutable handles can be used to avoid allocating a new handle on every\niteration.")),(0,r.kt)("h2",{id:"object-model"},"Object Model"),(0,r.kt)("p",null,'Currently the object model is a VTable-based scheme,\nin which all possible JS values inherit from a base garbage collector VTable.\nThese are called "cells", and all the cells are defined in ',(0,r.kt)("inlineCode",{parentName:"p"},"CellKinds.def"),".\nObjects have a special ",(0,r.kt)("inlineCode",{parentName:"p"},"ObjectVTable"),", Callables have a ",(0,r.kt)("inlineCode",{parentName:"p"},"CallableVTable"),", etc."),(0,r.kt)("h3",{id:"objects"},"Objects"),(0,r.kt)("p",null,"Each JS object is represented by ",(0,r.kt)("inlineCode",{parentName:"p"},"Object")," (or a class derived from ",(0,r.kt)("inlineCode",{parentName:"p"},"Object"),').\nJS objects have a set of name/value pairs, and some optional "indexed storage".\nRead more about how ',(0,r.kt)("inlineCode",{parentName:"p"},"Object")," works in ",(0,r.kt)("inlineCode",{parentName:"p"},"ObjectModel.h"),".\nThe Runtime contains a global object which is used to store in global scope."),(0,r.kt)("h3",{id:"arrays"},"Arrays"),(0,r.kt)("p",null,"Arrays, the ",(0,r.kt)("inlineCode",{parentName:"p"},"arguments")," object, etc. inherit from Object directly,\nbut simply provide their own implementations of ",(0,r.kt)("inlineCode",{parentName:"p"},"*OwnIndexed")," using the VTable."),(0,r.kt)("h3",{id:"functions"},"Functions"),(0,r.kt)("p",null,"Functions and native functions inherit from ",(0,r.kt)("inlineCode",{parentName:"p"},"Callable"),".\nThis allows them to call ",(0,r.kt)("inlineCode",{parentName:"p"},"executeCall*")," to run functions using the internal API."),(0,r.kt)("h3",{id:"boxed-primitives"},"Boxed Primitives"),(0,r.kt)("p",null,"The VM has classes used to contain Booleans, Strings, and Numbers,\nwhen they are constructed using their respective JS constructors.\n",(0,r.kt)("inlineCode",{parentName:"p"},"JSString")," is a boxed ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," object, etc."),(0,r.kt)("h2",{id:"repl"},"REPL"),(0,r.kt)("p",null,"The HermesVM provides a REPL in ",(0,r.kt)("inlineCode",{parentName:"p"},"bin/hermes"),",\nwhich calls through to the ",(0,r.kt)("inlineCode",{parentName:"p"},"eval()")," global function in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Runtime"),"."))}d.isMDXComponent=!0}}]);