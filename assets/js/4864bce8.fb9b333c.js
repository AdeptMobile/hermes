"use strict";(self.webpackChunkhermes_website=self.webpackChunkhermes_website||[]).push([[195],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return h}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(t),m=i,h=u["".concat(s,".").concat(m)]||u[m]||c[m]||o;return t?a.createElement(h,r(r({ref:n},d),{},{components:t})):a.createElement(h,r({ref:n},d))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[u]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3225:function(e,n,t){t.r(n),t.d(n,{assets:function(){return d},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return u}});var a=t(3117),i=t(102),o=(t(7294),t(3905)),r=["components"],l={id:"vm",title:"VM Overview"},s=void 0,p={unversionedId:"vm",id:"vm",title:"VM Overview",description:"Value Representation",source:"@site/../doc/VM.md",sourceDirName:".",slug:"/vm",permalink:"/docs/vm",draft:!1,editUrl:"https://github.com/facebook/hermes/blob/HEAD/website/../doc/VM.md",tags:[],version:"current",lastUpdatedAt:1624441662,formattedLastUpdatedAt:"Jun 23, 2021",frontMatter:{id:"vm",title:"VM Overview"},sidebar:"docs",previous:{title:"Design of the Optimizer",permalink:"/docs/optimizer"},next:{title:"The GenGC Garbage Collector",permalink:"/docs/gengc"}},d={},u=[{value:"Value Representation",id:"value-representation",level:2},{value:"HermesValue",id:"hermesvalue",level:3},{value:"HermesValue32",id:"hermesvalue32",level:3},{value:"Strings",id:"strings",level:3},{value:"Runtime",id:"runtime",level:2},{value:"Runtime Module",id:"runtime-module",level:3},{value:"Runtime Identifiers",id:"runtime-identifiers",level:3},{value:"Garbage Collection",id:"garbage-collection",level:3},{value:"Rules for using handles",id:"rules-for-using-handles",level:4},{value:"Object Model",id:"object-model",level:2},{value:"Objects",id:"objects",level:3},{value:"Arrays",id:"arrays",level:3},{value:"Functions",id:"functions",level:3},{value:"Boxed Primitives",id:"boxed-primitives",level:3},{value:"REPL",id:"repl",level:2}],c={toc:u},m="wrapper";function h(e){var n=e.components,t=(0,i.Z)(e,r);return(0,o.kt)(m,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"value-representation"},"Value Representation"),(0,o.kt)("h3",{id:"hermesvalue"},"HermesValue"),(0,o.kt)("p",null,"The VM uses a class called ",(0,o.kt)("inlineCode",{parentName:"p"},"HermesValue")," to encapsulate JS values efficiently,\npreserving their type while still allowing them to fit in a register.\nNaN-tagging is used to store different types of values;\nwe store values in the lower bits of a ",(0,o.kt)("inlineCode",{parentName:"p"},"uint64_t"),".\nThus, when the ",(0,o.kt)("inlineCode",{parentName:"p"},"uint64_t")," is interpreted as a ",(0,o.kt)("inlineCode",{parentName:"p"},"double"),",\ntagged ",(0,o.kt)("inlineCode",{parentName:"p"},"NaN")," values can hold non-",(0,o.kt)("inlineCode",{parentName:"p"},"double")," types."),(0,o.kt)("p",null,"After we reserve the canonical quiet NaN to be used as the NaN representation\nin the VM, we have 51 remaining bits we can set. Even on 64-bit systems, we are\nable to accommodate a full pointer and type tag, since pointers are never more\nthan 48 bits in practice."),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"HermesValue")," can take on any of the following types of values, which are\ndistinguished by their type tag:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Empty"),(0,o.kt)("li",{parentName:"ol"},"Undefined"),(0,o.kt)("li",{parentName:"ol"},"Null"),(0,o.kt)("li",{parentName:"ol"},"Boolean"),(0,o.kt)("li",{parentName:"ol"},"Symbol"),(0,o.kt)("li",{parentName:"ol"},"Native value (used to store an int or pointer for bookkeeping)"),(0,o.kt)("li",{parentName:"ol"},"String pointer"),(0,o.kt)("li",{parentName:"ol"},"Object pointer")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"HermesValue")," is used across the VM to store and pass JS values.\n",(0,o.kt)("inlineCode",{parentName:"p"},"PinnedHermesValue")," is used in non-moveable memory, primarily for the register\nstack and other GC roots in known locations in memory. ",(0,o.kt)("inlineCode",{parentName:"p"},"GCHermesValue"),"s are\nused on the GC managed heap."),(0,o.kt)("h3",{id:"hermesvalue32"},"HermesValue32"),(0,o.kt)("p",null,"When compressed pointers are enabled, we also encode some values in a compact\n32-bit representation called ",(0,o.kt)("inlineCode",{parentName:"p"},"HermesValue32"),". Because compressing pointers to\nstore in this format requires additional work, we also avoid using\n",(0,o.kt)("inlineCode",{parentName:"p"},"HermesValue32")," for frequently accessed values (like the register stack).\nInstead we selectively use ",(0,o.kt)("inlineCode",{parentName:"p"},"HermesValue32")," for objects that are known to\nconsume a large percentage of heap memory, but that are unlikely to affect\nperformance."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"HermesValue32")," supports storing all of the types that ",(0,o.kt)("inlineCode",{parentName:"p"},"HermesValue")," does,\nexcept for native values, which were dropped because they are relatively rare\nand because we do not have a mechanism for compressing native pointers outside\nthe GC managed heap."),(0,o.kt)("p",null,"Instead of using NaN boxing, it takes advantage of the 8-byte alignment of the\nHermes heap to store tags, since the lowest 3 bits of a pointer are always\nguaranteed to be zero (even after compression)."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"HermesValue32")," also requires special handling for doubles. It is able to store\nsmall integers up to 29 bits inline, but anything that cannot be represented in\nthat form must be stored as a separate double object on the heap. Based on the\nworkloads we have looked at, actual doubles are very rarely used, so the\noverhead of this approach is small."),(0,o.kt)("h3",{id:"strings"},"Strings"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"StringPrimitive")," is used to store immutable UTF16 encoded strings,\nand ",(0,o.kt)("inlineCode",{parentName:"p"},"StringPrimitive *")," can be stored in ",(0,o.kt)("inlineCode",{parentName:"p"},"HermesValue")," to make JS String values."),(0,o.kt)("p",null,"Internally, ",(0,o.kt)("inlineCode",{parentName:"p"},"StringPrimitive")," can be"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DynamicStringPrimitive")," (stored in the GC heap)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ExternalStringPrimitive")," (stored as a pointer outside the VM, such as into a bytecode file)")),(0,o.kt)("h2",{id:"runtime"},"Runtime"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Runtime")," class is the primary driver of the VM.\nIt contains the current environment and heap, as well as the code to execute.\n",(0,o.kt)("inlineCode",{parentName:"p"},"Runtime")," is used to execute ",(0,o.kt)("inlineCode",{parentName:"p"},"RuntimeModule"),"s,\nwhich are constructed from ",(0,o.kt)("inlineCode",{parentName:"p"},"BytecodeModule"),"s using ",(0,o.kt)("inlineCode",{parentName:"p"},"Runtime::runModule()"),"."),(0,o.kt)("h3",{id:"runtime-module"},"Runtime Module"),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"RuntimeModule")," is the VM representation into a bytecode file.\n",(0,o.kt)("inlineCode",{parentName:"p"},"RuntimeModule"),"s are stored outside the GC heap and are constructed via ",(0,o.kt)("inlineCode",{parentName:"p"},"new"),"."),(0,o.kt)("p",null,"To allow for segmentation of bytecode files and ",(0,o.kt)("inlineCode",{parentName:"p"},"require"),"ing modules between\nseparate segments, we collect ",(0,o.kt)("inlineCode",{parentName:"p"},"RuntimeModule"),"s in a class called ",(0,o.kt)("inlineCode",{parentName:"p"},"Domain"),".\nYou may think of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Domain")," as the collection of bytecode files which were\nall compiled in the same invocation of the compiler."),(0,o.kt)("p",null,"Every ",(0,o.kt)("inlineCode",{parentName:"p"},"JSFunction")," shares ownership of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Domain"),", and the ",(0,o.kt)("inlineCode",{parentName:"p"},"Domain")," owns\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"RuntimeModule"),"s which provide those functions. In this way, when all\n",(0,o.kt)("inlineCode",{parentName:"p"},"JSFunction"),"s which require the files in a ",(0,o.kt)("inlineCode",{parentName:"p"},"Domain")," are collected,\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"Domain")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"RuntimeModule"),"s are also collected."),(0,o.kt)("h3",{id:"runtime-identifiers"},"Runtime Identifiers"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Runtime")," contains an ",(0,o.kt)("inlineCode",{parentName:"p"},"IdentifierTable"),",\nwhich is used for getting unique IDs for strings.\nThe table is used to go from ",(0,o.kt)("inlineCode",{parentName:"p"},"StringPrimitive")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"SymbolID"),' and back.\nIt\'s prepopulated with some "predefined strings",\nthe set of strings that are required by built in functions,\nwhich can be seen in ',(0,o.kt)("inlineCode",{parentName:"p"},"PredefinedStrings.def"),"."),(0,o.kt)("h3",{id:"garbage-collection"},"Garbage Collection"),(0,o.kt)("p",null,"Currently, the VM uses ",(0,o.kt)("inlineCode",{parentName:"p"},"HadesGC")," by default, a concurrent garbage collector aimed at dramatically lowering pause times over our previous collector ",(0,o.kt)("a",{parentName:"p",href:"/docs/gengc"},"GenGC"),". The heap in Hermes is non-contiguous, which allows us to avoid reserving large regions of address space upfront, and allows us to return memory to the OS at a finer granularity. Garbage collection in Hermes is precise, which means that the GC always knows which values contain valid pointers."),(0,o.kt)("p",null,"See the documentation for ",(0,o.kt)("a",{parentName:"p",href:"/docs/hades"},"Hades")," for details\non how it works."),(0,o.kt)("p",null,"The garbage collector moves objects to different place on the heap,\ninvalidating ",(0,o.kt)("inlineCode",{parentName:"p"},"HermesValue"),"s,\nso there are a couple classes which allow updating them automatically.\n",(0,o.kt)("inlineCode",{parentName:"p"},"Handle<>")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Handle<T>")," are garbage collector-aware handles;\nthey are moved if a collection occurs in between two successive accesses.\nSo, to ensure correctness in the VM,\nuse the handles instead of passing raw ",(0,o.kt)("inlineCode",{parentName:"p"},"HermesValue")," between functions."),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"GCScope")," is used to keep track of all the current ",(0,o.kt)("inlineCode",{parentName:"p"},"HermesValue")," handles.\nAny ",(0,o.kt)("inlineCode",{parentName:"p"},"GCScope")," must be constructed on the stack,\nwhence it tracks any scoped handles that are used until it falls out of scope.\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"GCScope")," allocates space in chunks,\nand when it is destroyed (falls out of scope) it frees any chunks it allocated.\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"GCScope")," is used to internally generate ",(0,o.kt)("inlineCode",{parentName:"p"},"PinnedHermesValue"),"s,\nwhich are then stored in ",(0,o.kt)("inlineCode",{parentName:"p"},"Handle<>")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Handle<T>"),"."),(0,o.kt)("p",null,"We also provide ",(0,o.kt)("inlineCode",{parentName:"p"},"PseudoHandle<T>")," classes which are explicitly ",(0,o.kt)("em",{parentName:"p"},"not")," handles.\nThese are used to be explicit about storage of raw pointers and ",(0,o.kt)("inlineCode",{parentName:"p"},"HermesValue"),".\n",(0,o.kt)("inlineCode",{parentName:"p"},"PseudoHandle")," should be used as an argument in place of a raw pointer to\nfunctions which may want to turn that argument into a ",(0,o.kt)("inlineCode",{parentName:"p"},"Handle"),",\nbut in which it's not necessary to ",(0,o.kt)("em",{parentName:"p"},"always")," incur the cost of handle allocation.\n",(0,o.kt)("inlineCode",{parentName:"p"},"PseudoHandle")," also does not have a copy constructor,\nand moving out of one invalidates it.\nThis prevents the reuse of ",(0,o.kt)("inlineCode",{parentName:"p"},"PseudoHandle")," after an allocating function call."),(0,o.kt)("h4",{id:"rules-for-using-handles"},"Rules for using handles"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"A function that can perform an allocation (even if it doesn't do it every\ntime) or calls a function that does, must accept and return only handles\n(for GC-managed objects). It must also take a ",(0,o.kt)("inlineCode",{parentName:"li"},"Runtime*")," as an argument."),(0,o.kt)("li",{parentName:"ol"},"A function that accepts or returns handles is allowed (and can be assumed\nto) allocate more handles, but the upper bound of allocated handles must be\nstatic."),(0,o.kt)("li",{parentName:"ol"},"The number of handles in a given GCScope should have a static upper limit.")),(0,o.kt)("p",null,"The motivation for these rules should be self-explanatory.  The practical\nimplication of rule 2 and 3 is that recursion and loops that allocate handles\nin every iteration must be treated specially.  In case of recursion a new\nGCScope should be defined in each recurrence (is that the correct term?).  In\ncase of a loop, there are a couple of possibilities:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"in loops that are expected to be low iteration and not performance critical,\na new GCScope can be defined in the body of the loop."),(0,o.kt)("li",{parentName:"ul"},"otherwise a GCScope::Marker should be used to flush the allocated handles of\nthe previous iteration."),(0,o.kt)("li",{parentName:"ul"},"mutable handles can be used to avoid allocating a new handle on every\niteration.")),(0,o.kt)("h2",{id:"object-model"},"Object Model"),(0,o.kt)("p",null,'Currently the object model is a VTable-based scheme,\nin which all possible JS values inherit from a base garbage collector VTable.\nThese are called "cells", and all the cells are defined in ',(0,o.kt)("inlineCode",{parentName:"p"},"CellKinds.def"),".\nObjects have a special ",(0,o.kt)("inlineCode",{parentName:"p"},"ObjectVTable"),", Callables have a ",(0,o.kt)("inlineCode",{parentName:"p"},"CallableVTable"),", etc."),(0,o.kt)("h3",{id:"objects"},"Objects"),(0,o.kt)("p",null,"Each JS object is represented by ",(0,o.kt)("inlineCode",{parentName:"p"},"Object")," (or a class derived from ",(0,o.kt)("inlineCode",{parentName:"p"},"Object"),').\nJS objects have a set of name/value pairs, and some optional "indexed storage".\nRead more about how ',(0,o.kt)("inlineCode",{parentName:"p"},"Object")," works in ",(0,o.kt)("inlineCode",{parentName:"p"},"ObjectModel.h"),".\nThe Runtime contains a global object which is used to store in global scope."),(0,o.kt)("h3",{id:"arrays"},"Arrays"),(0,o.kt)("p",null,"Arrays, the ",(0,o.kt)("inlineCode",{parentName:"p"},"arguments")," object, etc. inherit from Object directly,\nbut simply provide their own implementations of ",(0,o.kt)("inlineCode",{parentName:"p"},"*OwnIndexed")," using the VTable."),(0,o.kt)("h3",{id:"functions"},"Functions"),(0,o.kt)("p",null,"Functions and native functions inherit from ",(0,o.kt)("inlineCode",{parentName:"p"},"Callable"),".\nThis allows them to call ",(0,o.kt)("inlineCode",{parentName:"p"},"executeCall*")," to run functions using the internal API."),(0,o.kt)("h3",{id:"boxed-primitives"},"Boxed Primitives"),(0,o.kt)("p",null,"The VM has classes used to contain Booleans, Strings, and Numbers,\nwhen they are constructed using their respective JS constructors.\n",(0,o.kt)("inlineCode",{parentName:"p"},"JSString")," is a boxed ",(0,o.kt)("inlineCode",{parentName:"p"},"String")," object, etc."),(0,o.kt)("h2",{id:"repl"},"REPL"),(0,o.kt)("p",null,"The HermesVM provides a REPL in ",(0,o.kt)("inlineCode",{parentName:"p"},"bin/hermes"),",\nwhich calls through to the ",(0,o.kt)("inlineCode",{parentName:"p"},"eval()")," global function in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Runtime"),"."))}h.isMDXComponent=!0}}]);